[{"id":0,"href":"/docs/","title":"Docs","section":"About","content":"About This Website #  This website is very much a work in progress growing in tandem to development on Dither. While some pages here have mostly fleshed out ideas, some aren\u0026rsquo;t even started yet or are in need of refinement or updating as other parts change. Please keep this is mind when reading these documents.\n"},{"id":1,"href":"/docs/spec/applications/","title":"Applications","section":"Docs","content":"Dither Application Index #  List of application Ideas #    Dither Chat - Community Chat application aiming to replace Discord. Provides e2ee encrypted DMs, voice chat, servers, voting, and integration with most other chat protocols.  Dithca - Comprehensive \u0026amp; Versatile decentralized comment system where anyone can comment on any type of data structure on Dither. Can interface with most other centralized comment systems and deal with misinformation \u0026amp; crediting using a comprehensive community flagging system.  Can be used to create Reddit / Twitter Replacement. Can be integrated into other Dither applications or ported to web.    Dithgit - Github on Dither  Dithix - Dither Resource Manager: Manage and cache any kind of resource, interface between the Merkle Tree and the Filesystem.  Nomia on Dither - Nomia on Dither,  Tree of Math - Directed Acyclic Graph linking a standardized data structure for defintions and proofs together based on set theory creating a comprehensive tree of knowledge.  Dither Coin - Cryptocurrency that solves all the current problems and creates a complete digital replication of cash (being decentralized, anonymous, non-volatile, and difficult to trace).  Dither DEX - A all-faceted decentralized exchange to facilitate trade any kind of real or virtual asset. Supports meeting up in real life or exchanging other virtual assets anonymously and securely. Also supports moderation, karmic filtering  Other Application Ideas: #   Manga \u0026amp; Reading App  UI will be similar to Tachiyomi, but will also support book reading. Pulls content from various websites and stores on Dither. Written in Flutter, desktop \u0026amp; mobile versions. Supports comments through Dithca. Has built-in feature for paying for translation \u0026amp; replacing bad translations with better translations if they are made.   YouTube replacement  pulls and stores videos in a decentralized, uncensorable manner from any site that youtube-dl supports Built-in chat (Using Dithca protocol) Community-generated captions, sections, sponsor segments (pulled from sponsorblock) flagging etc. Support for likes, view counting (and congregating), and \u0026ldquo;Hearts\u0026rdquo; (method of giving Dither Coin to creators). Automatic community flagging of stolen/used content (including music, other people\u0026rsquo;s videos, meme origins, pretty much anything) Community misinformation flagging of content (interfaces with Dithca)   Peer-to-Peer Exchange  Allow for the exchange    "},{"id":2,"href":"/docs/spec/applications/analytics/","title":"Analytics","section":"Docs","content":"Anonymous Analytics #  Analytic collection is usually non-respecting of privacy, but it should be possible to create a system of analytics that reveals as little identifying information as possible using information theory and the decentralized nature of Dither.\nRough Idea #  Author specifies what kind of analytics they want and how specific they want. Analytics must be proportions or averages. Users manually (or automatically based on settings) pick which fields they want to divulge. Peers that use a specific application are identified and an agreed upon field is set to be exchanged and averaged by each peer. Each peer checks the other\u0026rsquo;s proof of humanity (see zero-knowledge-proofs) and create a new zero-knowledge proof combining the ones of each peer.\nThis part needs more thought:\nThis field combination is done with many different peers until all of a given peer\u0026rsquo;s fields have been combined. Then more averages are produced and a tree of proofs is gradually built. until the top of the tree for each field contains the desired average or proportion which is publically viewable for all users to see.\n"},{"id":3,"href":"/docs/spec/applications/disp/compilation/","title":"Compilation","section":"Docs","content":"Compilation #  Disp is very modular by design and the compilation system is no exception.\nThe general process goes like this:\n User edits file File is interpreted down to a collection of data structures containing the symbols, functions, and type definitions of that file as well as any external modules that are referenced User runs program Various macros run to generate lower-level parts of the program, eventually compiling down to pure lambda calculus and monadic Funclets\u0026quot; representing any side effects the program might have.  Examples of some possible macros  type macro evaluates and creates structs of type Type  this macro generates a single symbol linking to a macro that generates a constructor for the type definition.   fn macro evaluates and creates structs of type Function     The lambda expression tree is traversed and each lambda expression is matched to a corresponding target instruction. The target instructions are joined together by platform-specific algorithms (i.e. for x86_64 register numbers are assigned to connect operations). The tree of instructions is then flattened and can be run as an executable or my a controlling program.  "},{"id":4,"href":"/docs/spec/applications/disp/de-brujin-index-alternative/","title":"De Brujin Index Alternative","section":"Docs","content":"Lambda Trees: A deduplication-friendly lambda-calculus construction #  The current most well known way of representing the lambda calculus is De Brujin Indicies.\nThis is where you have 3 variants of a lambda Term:\n Var(Number) - Number represents how many layers of abstraction (lambdas) the variable is away from its intended binding App(Term, ...) - Application is a list of Terms Lambda(Term) - Lambda represents an abstraction point  An example of what this might look like for common equations:\n λx . x = Lambda(Var(1)) λx. λy. x = Lambda(Lambda(Var(2))) λx. (x (λx . λy . x) (λx . λy . y)) = Lambda(App(Var(1), Lambda(Lambda(Var(1))), Lambda(Lambda(Var(2)))))  For Disp, I have devised an alternative method that doesn\u0026rsquo;t require integers (and thus is not limited by encoding constraints)\nDisp has the same 3 variants of Term:\n Var App(Term, Term) Lambda(PointerTree, Term)  In addition to a construct PointerTree:\n None End Branch(PointerTree, PointerTree)  In fact, the pointertree datastructure can be repurposed from the Term datastructure. (End = Var, None = Lambda(Var, Var), Branch(PointerTree, PointerTree) = App(Term, Term))\nCommon equation examples of this structure might look like:\n λx . x = Lambda(Var, Var) λx. λy. x = Lambda(Var, Lambda(None, Var)) λx. (x (λx . λy . y) (λx . λy . x)) = Lambda(Branch(Branch(End, None), None), App( App( Var, Lambda(None, Lambda(Var, Var)) ), Lambda(Var, Lambda(None, Var)) ) As opposed to De Brujin indices where the variables \u0026ldquo;point\u0026rdquo; to their corresponding lambda abstractions, with Lambda Trees, the lambda terms carry an auxiliary datastructure specifying exactly which Variables should be replaced.  In addition when it comes to storage and integration with Dither, these lambda expressions are identified by hash which gives a datastructure like this:\n Var App(Hash, Hash) Lambda(Hash, Hash)  This version of lambda calculus has been implemented in the disp repository\n"},{"id":5,"href":"/docs/spec/applications/disp/disp/","title":"Disp","section":"Docs","content":"Disp (Dither-Lisp) (WIP) #  Everything is data. Programs are interpreted data that manipulates other pieces of data.\nDisp is a programming language that takes this concept to its logical conclusion with some functional programming and type theory sprinkled in where programs are composed functions and functions are data.\nGoals #   Extremely fast compile times Extremely fast execution time Support for any possible cpu or interpreter Maximum re-use of code (data) Interface for defining hashtypes and hashtraits.  Ideas #   Goal of compilation is cpu-specific object file complete with  data pre-loaded into memory list of cpu-specific instructions. hash of external virtual kernel API (i.e. syscall functions)   virtual kernel APIs can be constrained to give programs access to different parts of the computer, or forgone entirely for programs that only manipulate data. Running object files requires a uniquely setup syscall kernel API that can deal with interrupts  General Architecture #    Functions are the core of Disp. There is no compiler, there are just collections of macros (i.e. functions that transform functions). See the function spec\n  All language types are themselves self-defining structures, including the final bytecode file.\n  The language files are not stored as text files, they are instead stored as self-defining structures of groups of commands.\n  "},{"id":6,"href":"/docs/spec/applications/disp/examples/assembly/6502-assembly/","title":"6502 Assembly","section":"Docs","content":"Disp compiling to 6402 Bytecode #  6402 assembly has a relatively small number of instructions so it is a good starting point when looking at how compiling works in Disp.\nInstruction Abstraction #  To work in disp, first every 6502 instruction must be abstracted out to either a pure function or a monadic function.\nPure functions are easy to derive. Take for example the INX (Increment X) instruction for the 6502.\nThe INX instruction simply increments the X register. In Disp, this is represented as a pure function that inputs and outputs 3 types: RegisterX, FlagZero and FlagNegative. This represents the 6502\u0026rsquo;s INX instruction writing to those 3 locations.\nINX = (Register::X) -\u0026gt; (Register::X Flag::(Zero Negative))\nIt can be furthur abstracted to be a general \u0026ldquo;Increment Register\u0026rdquo; function which works for registers A, X \u0026amp; Y:\n INCR = Register -\u0026gt; (Register Flag::(Zero Negative))  For instructions with operands abstraction is much more complicated. The ADC instruction has 8 variants, some of which are pure and some of which access memory in a non-deterministic way (and are not pure).\nThe 2 of the 8 variants of ADC are represented as follows:\n immediate: ADC #oper  ADC = (RegisterA Immediate) -\u0026gt; (RegisterA Flag::(Negative Zero Carry Overflow))   absolute: ADC oper  ADC = (RegisterA, Memory, Flag::(Negative Zero Carry Overflow)) -\u0026gt; (RegisterA, Memory, Flag::(Negative Zero Carry Overflow))    For LDA\n immediate: LDA #oper  LDA = (RegisterA, Immediate) -\u0026gt; (RegisterA Flag::(Negative Zero))   absolute: LDA #oper  LDA = (RegisterA, Memory) -\u0026gt; (RegisterA Flag::(Negative Zero))    For TAX\n implied: TAX  TAX = (RegisterA RegisterT) -\u0026gt; (RegisterT)    Low-level 6502 assembly in disp might look like:\nuse 6502; code compile 6502 ( set (registers flags memory) 6502::CPU set A registers.a set A 6502::LDA(5) // load 5 into A and add 5 using a pipeline set A (\u0026gt; A 6502::LDA(5).0 6502::ADC(5).0) set X registers.x set X TAX(A) set load_5_a 6502::LDA(5).0 set add_5_a 6502::ADC(5).0 // general \u0026quot;set\u0026quot; function set set_a func (a:RegisterA RegisterA (\u0026gt; a ) ) // does same thing set A (set_a A) ) "},{"id":7,"href":"/docs/spec/applications/disp/examples/assembly/hello-world/","title":"Hello World","section":"Docs","content":"Assembly Layer #  Disp compiles directly from high-level to cpu machine code. This means that it is possible to write low-level assembly commands directly within high-level code (although this is a bad idea)\nx86-64 #  This is a simple Hello World program for linux written in x86 assembly compiled with nasm.\nglobal _start section .data msg: db \u0026#34;Hello, world!\u0026#34;, 10 msglen: equ $ - msg section .text _start: mov rax, 1 ; write(  mov rdi, 1 ; STDOUT_FILENO,  mov rsi, msg ; \u0026#34;Hello, world!\\n\u0026#34;,  mov rdx, msglen ; sizeof(\u0026#34;Hello, world!\\n\u0026#34;)  syscall ; );  mov rax, 60 ; exit(  mov rdi, 0 ; EXIT_SUCCESS  syscall ; );  compiled: nasm -f elf64 hello.s \u0026amp;\u0026amp; ld -o hello hello.o \u0026amp;\u0026amp; ./hello,\nIn Disp, this might look something like:\n(use std::default::*) (use std::assembly) (use std::x86_64::{ops::{mov, syscall}, reg::{rax, rdi, rsi}}) (use std::linux::{syscall::{WRITE, EXIT},const::{STDOUT_FILENO, EXIT_SUCCESS}}) // Defines hello world string constant, structured as \u0026lt;B64\u0026gt;\u0026lt;DATA\u0026gt; (let hello_world:String \u0026quot;Hello, World!\u0026quot;) // Assembly Macro defines \u0026quot;mem\u0026quot; macro. // Every time mem macro is invoked, it adds passed object to buffer returns byte location in buffer. (assembly (let msg (mem hello_world)) // Add string to buffer \u0026amp; set msg to location of string (mem ( // Add assembly to mem // mov is a macro defined in the ::x86_64 collection. It resolves 2 passed arguments as B64 and outputs a x86_64::Operation type. (mov rax WRITE) (mov rdi STDOUT_FILENO) (mov rsi msg) (mov rdx (len hello_world)) (syscall) (mov rax EXIT) (mov rdi EXIT_SUCCESS) (syscall) )) ) "},{"id":8,"href":"/docs/spec/applications/disp/funclets/","title":"Funclets","section":"Docs","content":"Funclets #  Funclets are types in disp that together form a functional abstraction over the stateful nature of CPU instructions. They are the basic building blocks of every Function in disp and can be easily combined, customized, and compiled to specific target platforms.\nEach funclet is a unique identifier that links to code that can turn it into cpu-specific procedures via reverse hash lookup.\nAn example #  One example of a funclet would be the add operation. This is a function that takes two numbers and returns their sum. On modern cpus there are typically different add instructions for differently sized integers. In addition, there is a lot of extraneous behavior that happens on some cpus i.e. setting arithmatic flags such as \u0026ldquo;carry\u0026rdquo;, \u0026ldquo;overflow\u0026rdquo;, \u0026ldquo;parity\u0026rdquo; and \u0026ldquo;is zero\u0026rdquo;.\nThe way disp goes about dealing with all this complexity is finding the simplest possible definition of add and adding functionality through variations of the Funclet and other funclets composed together.\nadd is a Funclet. It takes 2 binary numbers and outputs another binary number.\nadd\u0026lt;N: DispNumber\u0026gt;(location: N, location: N) -\u0026gt; N, carry\nVariations #  Variations of this funclet are conceptually endless, but commonly used variations might be:\n add(u8, u8) -\u0026gt; u8 - unsigned addition add(i16, i16) -\u0026gt; i16 - signed addition add(u1024, u1024) -\u0026gt; u1024 - large additions ( ADC on x86_64) You can also add sign-extended integers\u0026hellip; add(u32, u32) -\u0026gt; u64 add(i32, i32) -\u0026gt; i64 Carry bit can be extracted as shared Funclet value add(u8, u8) -\u0026gt; u8, carry And then used in other instructions like run(func, if_carry(carry)) - compiles to x86\u0026rsquo;s jc instruction  Extensions #  Extensions of a funclet are used to \u0026ldquo;rope in\u0026rdquo; side effects unconnected to the operation the cpu might have performed in the background when doing the operation. For example, on x86 cpus, the add instruction sets the overflow, sign, zero, adjust and parity flags in addition to the carry flag). These flags can be accessed through extensions.\nThe Parity extension is a Funclet that takes a location and returns a parity. To extend the add funclet, the parity funclet checks if the location input to the parity was the result of an add instruction. If it is, it doesn\u0026rsquo;t need to do anything because the cpu sets the parity flag automatically. If the input location is not an instruction that sets the parity bit, parity is calculated via cpu-specific instructions.\nThere is only one variation of parity:\n parity(location) -\u0026gt; location, parity  "},{"id":9,"href":"/docs/spec/applications/disp/functions/","title":"Functions","section":"Docs","content":"Functions #  The end goal of a compilation process is to generate data that can be interpreted by a cpu or an interpreter. This is typically called \u0026ldquo;bytecode\u0026rdquo; or \u0026ldquo;intermediate language\u0026rdquo;.\nEverything in disp is represented by lambda calculus. The compilation process is simply figuring out how to map lambda function hashes to pieces of output data.\nSay there is a lambda expression that when applied to two 8-long pair of type either true or false, it reduces to a single 8-long pair. This would represent an 8-bit \u0026ldquo;add\u0026rdquo; operation when this lambda expression is encountered in compilation, it will be marked as having a valid \u0026ldquo;target representation\u0026rdquo;.\nAs long as the whole of the lambda program can be marked with analagous operations in the target language, post processing will be done to connect all the operations with necessary glue code (like designating registers and memory allocation).\nExample of Abstraction #  Imagine the simplest program: \u0026ldquo;Hello World\u0026rdquo; written for Linux.\nIn a high level language, this might be just one line of code. However, if you descend down the layers of abstraction a simple hello world program is not so simple at all.\nAssuming a significantly low-level target platform (i.e. machinecode), this hello world program requires knowledge of cpu operations to move the data around as well as knowledge of the specific kernel calls necessary to write to the necessary user-facing output (unix standard output in this case).\nOn a different kernel or cpu, the essence of what is happening is the same, but the instructions are different. This is where disp comes into play.\n"},{"id":10,"href":"/docs/spec/applications/disp/live-rollbacks/","title":"Live Rollbacks","section":"Docs","content":"Live Rollbacks #  While disp is a compiled language, it is also a purely functional language which means that changes to state can be saved in an efficient manner and rolled back when necessary.\nThis means that a user can change the code of the program and while the program is running, updates parts of the running process\u0026rsquo;s code and roll back the program to the state before the process ran the code.\n"},{"id":11,"href":"/docs/spec/applications/disp/syntax/","title":"Syntax","section":"Docs","content":"Syntax #  Disp\u0026rsquo;s default syntax is similar to lisp with some Rust naming conventions sprinkled in. However, since disp files are stored as binary objects, disp code can be displayed in any way preferred by the programmer (javascript-like rust-like go-like etc.)\nExamples #  // This is a comment, it also doubles as documentation // Variables (set ten 10:b64) // variable names can have most symbols in them (set ten? 10) // literal 10 resolves to 10:bsize (use std::flow::assert) (assert_exact ten ten?) // =\u0026gt; true only on 64-bit systems, because bsize = b64 (assert_eq ten ten?) // =\u0026gt; always true // Reason about functions (use std::code::compile) (assert_exact // Parentheses implied compile `(a b) `(assert_eq a b) compile `(a b) `(panic_if (!= a b)) compile `(a b) `(if (= a b) (panic)) ) // =\u0026gt; these functions are the exact same when compiled // Strings (set string \u0026quot;Hello, World!\u0026quot;) // implies \u0026quot;Hello, World!\u0026quot;:String // String declaration follows the same declaration convention as Rust, except that Strings are stack-allocated by default. (print string) // =\u0026gt; prints out \u0026quot;Hello, World!\u0026quot; (print \u0026quot;And the God of Programming said: {:?}\u0026quot; string) // =\u0026gt; prints out formatted string with debug representation of string. // Type definition (with type macro) (type SomeStruct number b64 _ (String Character) ) // This macro resolves to something similar to using the formats of Type and TypeLocalization hashtype. (set SomeStruct ( (hash b64) ( (hash String) (hash Character)):Type)) (set SomeStructLocalization ((hash SomeStruct) ):TypeLocalization) // Trait definition using trait macro // A trait defines a collection of adjacent data (either a function, or a value) that is attached to a Type (trait SomeTrait fn size (\u0026amp;self) (usize) ) (impl AddOne SomeStruct set add_one (fn (~self) (self) ( (inc (loc self number) 1) (self) )) ) // Initiate SomeStruct with values // symbol = thing notation is equivalent to (set symbol thing) some_struct = (1098342 (\u0026quot;Hello, World!\u0026quot;, 'u')):SomeStruct (some_struct size) (1098342:B64 -12304: String:\u0026quot;hello there\u0026quot; Symbol:hello) "},{"id":12,"href":"/docs/spec/applications/disp/types/","title":"Types","section":"Docs","content":"Types #  There are various core types in Disp here are some main ones pertaining to compilation.\nThe Funclet type facilitates the compilation from functional human-reasonable code to procedural machine-interpreted code without compromising performance.\nFunclet is generic over an instance of CompilationTarget. type Funclet\u0026lt;Target: CompilationTarget\u0026gt;\n input: Target::StateLocation  CompilationTarget describes all the necessary details to convert a chain of Funclets to a list of Operations trait CompilationTarget\n type StateLocation - a type definition for a location in a global state used by Funclets.   Expression type Expression\n parameters: List\u0026lt;Type\u0026gt;  The Function type defines all behavior. It is generic over two instances of Type that implement the Size trait. type Function\u0026lt;Input: Type + Size, Output: Type + Size\u0026gt;\n input: Input output: Output body: List\u0026lt;Expression\u0026gt; impl Valid for Function  pseudo: valid only if last expression of body evaluates to type O.   //  type Macro = Function\u0026lt;Expression\u0026gt;\ntype Operation\ntype Procedure\n"},{"id":13,"href":"/docs/spec/applications/dithca/","title":"Dithca","section":"Docs","content":"Dithca #  A comprehensive commenting system built on top of Dither #  Decentralized comment system adaptor. Fully customizable comment system stored as a Dither Consensus Chain that can be created from any piece of data. Uses Reddit\u0026rsquo;s upvote/downvote system by default Acts on its own or as a proxy overlay to various comment sites.\nComment Chain #  WIP: Figure out how dither consensus works\nComment Sort methods #  https://medium.com/hacking-and-gonzo/how-reddit-ranking-algorithms-work-ef111e33d0d9\n"},{"id":14,"href":"/docs/spec/applications/dither-chat/","title":"Dither Chat","section":"Docs","content":"Dither Chat #    Dither Chat   What is it  Users \u0026amp; Sync  Chat Events  Event Storage - Storage of a sequence of events in memory or storage  Trusted Friends Application API  Chat Interface  Direct Messaging  Group messaging  Servers   Roles, Tags \u0026amp; Colors      What is it #  Dither Chat is a decentralized communication application using the Dither protocol. Servers are communally hosted with local consensus. Bots and plugins will be supported and also communally hosted. tl;dr Discord but decentralized and better.\nUsers \u0026amp; Sync #   Each user may have multiple Peers (devices that Dither is installed on) Chat Event history can be optionally synced across Peers. A peer may host multiple users Each UserId must have at least 1 peer that hosts it.  Chat Events #   All Events are signed with the private key of the person who sent it (these will be verified with a config option to let through or ignore unsigned or incorrectly signed events) Chat Message structure  Date sent, last edited, markdown data / embed json, UserID mentions, emoji reactions   Rich Presence (updating custom statuses and online/offline status)  Optional storage - can store presence update history (off by default) Optional sending, extracts information about what you are currently doing and updates your friends. (on by default) Customization options to only share with certain friends    Event Storage - Storage of a sequence of events in memory or storage #   Stored as hash-linked local blocktree that messages are added to and new blocks are created when a certain amount of time elapses between the last message sent or max block size exceeded. Block size can be set to 1 to prevent messages being ordered out-of-order. Indexing can be done on a by-block level (TODO: more customization options needed) Block structure can allow for thread branching \u0026amp; thread conversation movement across users. (e.g. create a group dm on top of an ongoing conversation)  Trusted Friends Application API #   Option to rank friends manually or by how much you chat with them Can mark friends as “Trusted, Neutral or Untrusted” Friend rank can be used by other applications e.g. for Stellar Consensus Protocol quorum selection  Chat Interface #   Built-in markdown formatting + advanced chat box (similar to discord) Link Displaying Metadata can be sent so receiver doesn’t have to send request to web pages TODO: Do we need to worry about invalid metadata being sent, tricking the user? Perhaps just scanning for suspicious domains is enough. Receivers can choose if they want to fetch link data, only fetch commonly used sites (e.g. youtube, twitter, soundcloud etc.) or not fetch anything at all and only display sent link metadata  Direct Messaging #   Simply sending JSON-encoded message/other events to UserID on Dither  Group messaging #   Messages are broadcast over gossipsub and conflicting blocks are ordered by time.  Servers #   Servers are communially hosted by the moderator\u0026rsquo;s computers. However, the owner has full control over the server and can choose who can assist Red Nodes are hosting nodes, blue nodes are members. Blue node with yellow stroke is proxying it\u0026rsquo;s connection to the server Image of a possible dither-chat server arrangement  Roles, Tags \u0026amp; Colors #   To distinguish people in a server, there are roles, name colors, and tags Tags are shown next to tagowner\u0026rsquo;s name as a small icon (like in Discord)  By default there is only 1 tag enabled for a server: the Owner tag. There are other tag presets such as Donator, Moderator \u0026amp; Member Custom tags can be created and be attached to a specific role. Tags should be displayed in order of importance   Roles can be made for anyone and can have permissions attached to them  Roles and can also be organized into hierarchies where users can be ranked-up to posses a higher role (usually with more permissions)   Each role has a color and color priority assigned  This is used to determine what color a user\u0026rsquo;s username should be assigned    "},{"id":15,"href":"/docs/spec/applications/dither-coin/","title":"Dither Coin","section":"Docs","content":"Dither Coin (Ideas are Work-In-Progress) #  Dither\u0026rsquo;s built-in cryptocurrency aims to solve all existing problems with crypto:\n Scalability  Uses IOTA block structure combined with Federated Byzantine Voting for coordination. Most users won\u0026rsquo;t store the entire network history, just a slice of the current state relevent to performing transactions.   Speed  Using Stellar Consensus Protocol and IOTA will be helpful to speed. Bad Idea?: Also, there will be establishment of Zones in the network that have their own sub-exchanging separate from the rest of the network for fast local transactions. Usage of zones will be faster than sending transactions to the global network, however, for security purposes, zones must report transactions   Anonymity  Will use zk-STARKS to obfuscate transaction amounts and sender   Transaction Cost  Network is maintained by users, no mining necessary, therefore no fees will be required to transfer tokens.   Volatility  There will be a system of provable currency deletion where you can create Dither Coins from thin air by proving that you send a certain amount of other support crypto coins to a public key with no corresponding private key (i.e. proving that they are inaccessable). The amount of coins created will be market exchange rate of the given coin into the U.S. dollar at the time of the transaction. (exchange rate is maintained by the network) This will ensure that the value of Dithercoin is tied to the US dollar.   Ease of Use  Dither Coin will be built-in to all aspects of Dither for tipping and other things There will be SDKs so that Dither Coin can be built into other applications.   Ease of Purchase  A system for peer-to-peer purchase of Dither Coin using other assets will be created using Dither Chain. (Idea WIP)    "},{"id":16,"href":"/docs/spec/applications/dither-dex/","title":"Dither Dex","section":"Docs","content":"Dither Decentralized Exchange #  An exchange is a place that facilitates the exchange of goods (usually intangible ones). The Dither Exchange will be primarily geared towards the exchange of intangible goods, but it will support selling physical goods as well.\nThe core mechanism of the exchange is publically listing sell and buy orders and making them easily acessible to peers that satisfy certain constraints. (Perhaps they must prove that they are within a certain distance to the seller or that they have a certain amount of specific karma).\n"},{"id":17,"href":"/docs/spec/applications/dither-git/","title":"Dither Git","section":"Docs","content":"Dither-git #  Extension for Git allowing for interaction with git repositories hosted on Dither.\nIdeas #   Pull requests and issues can be opened on any file or directory. Since everything is a content-addressed DAG, git repositories can contain other git repositories and share data with other git repositories naturally.  People will be able to see using reverse-hash-lookup newer versions of shared files and be able to update them in their own repository.    Trait Ideas #  Binary\n data: List\u0026lt;Byte\u0026gt; - file data blob  File\n name: String, creation_date: Timestamp, data:  Directory\n files: List\u0026lt;Link\u0026lt;File\u0026gt;\u0026gt;  GitObject\n changed_file:   Contains Link to File or Directory \u0026amp; Link to previous GitObject.    Commit - Contains list of GitObjects that represent changed files / directories and previous Commit\nGitRepo - Contains latest Commit\n"},{"id":18,"href":"/docs/spec/applications/dither-versioning/","title":"Dither Versioning","section":"Docs","content":"Dither Versioning (dv) #  This is a versioning system for versioning any kind of tree structure. It is meant to function as a replacement for git.\nGeneral Structure #  ObjectDelta: - Generates an Object with a change\n object: Link\u0026lt;Object\u0026gt;(link_type: Relevent) base_object: Link\u0026lt;Object, Linked\u0026gt;  Object: - Compressed Object, Binary or Text\n base_object: Option\u0026lt;ObjectDelta\u0026gt; compresed data: List\u0026lt;Byte\u0026gt;  "},{"id":19,"href":"/docs/spec/applications/dithix/","title":"Dithix","section":"Docs","content":"Dithix #  Solves the packaging problem\nTakes ideas from: Nix\nFeatures of a good package manager:\n Download packages Run packages Update packages Hack on packages Deploy packages Reproducibly configure packages across many different systems Package storage \u0026amp; versioning + deduplication  Package trait is valid if the output is built from the derivation\nDownloading Packages #  This is handled by Dither. Package name is mapped to a release hash tree w/summary and the desired version is selected.\nThe dependency network #  All package managers need to manage dependency downloading and configuration. They need to be able to manage multiple versions of the same library. Dynamically linked executables are very much desired in Dithix for efficiency so packages are preferred to split compilation into multiple linked derivations instead of one single one.\nIt works exactly like a hash tree. All packages contain the hash of their inputs and compiled packages can be looked up on the network with unique names.\nPackages on Dither #  Package definitions are created using a functional configuration language (i.e. tweag/nickel).\n  Trait \u0026ldquo;Script\u0026rdquo;\n parser: Nickel / Nix / Whatever functionnal configuration language file: File    Trait \u0026ldquo;Derivation\u0026rdquo;\n builder: Package // Package that builds the output inputs: List\u0026lt;Package\u0026gt; // Input Packages    Trait \u0026ldquo;Package\u0026rdquo; // Is valid if output is reproducibly producted from derivation which is reproducibly produced from definition\n definition: Script // Parsed into a the derivation derivation: Derivation // Compiled into an output output: Multihash // Contains everything needed to run a program    "},{"id":20,"href":"/docs/spec/applications/nomia/","title":"Nomia","section":"Docs","content":"Nomia is a program that allows for the standardization of composing data. Names, Resources \u0026amp; Systems in Nomia will be able to be represented and stored in Dither.\n"},{"id":21,"href":"/docs/spec/applications/predictive-keyboard/","title":"Predictive Keyboard","section":"Docs","content":"Predictive Keyboard #  Inspired by the way China does predictive typing ( Johnny Harris). And how various keyboards on mobile platforms aggregate the usage data of many people\n"},{"id":22,"href":"/docs/spec/applications/protocol-of-truth/examples/","title":"Examples","section":"Docs","content":"Potential Examples for the Protocol of Truth #  To flesh out the idea and provide context of what this might look like, here are some real-world examples of videos that would be labeled under the protocol of truth.\nExample 1: Simple Factual Error #  In Youtuber Fireship\u0026rsquo;s video \u0026ldquo;Rust in 100 Seconds\u0026rdquo; at 0:55 he incorrectly says that mutable values are stored in the heap.\nIdeal processes of correction:\n Someone realizes that there is an error and creates an Objection  Objections come with 3 parts: Selection, Type, Reason, and Evidence For the Selection, they use the Transcript selection type and select the following lines: 00:55 mutable values or objects with an 00:57 unknown size at compile time are stored 00:59 in the heap memory  They set the Type to Error. For the Reason they say:  \u0026quot;While objects with unknown size at compile time are typically stored in the heap, mutable objects can be stored on the stack OR the heap.\u0026quot;  They do not give any Evidence as this is common knowledge in rust.   As people come to the video, they see the label on the video as Pending - Potential Error and click to see the Objection to do one of the following:  Mark the Objection as True Mark the Objection as False Flag the Objection as Incomplete Flag the Objection as Unknown   When flagging an Objection, you must have at least 10 karma and a verified human account. If you mark an objection as True while the statement is resolved as false or vice versa, you will loose 5 truth karma. If marked correctly you will gain 1 truth karma. Confident people may also stake 100, 1000, or 10,000 karma to add 2, 3, or 4 votes respectively. (You will also loose half of your staked karma if you mark incorrectly, although you will gain more points if guessed correctly). People may also stake their karma (max 10) on a resolution for increased karma return when the Objection comes to consensus in their favor. that they agree or that they are completely confident with the Objection (beause it is obvious). Or they comment under the objection with If after a substantial period of time there is a 4/5th majority either way (True or False or Unknown), the objection will be marked true or false, which will change the label of the video. If there is no super consensus, it is marked as controversial. Controversial resolutions will only effect the video label for certain Objection types. Ideally, the creator sees the Objection and the supporting \u0026ldquo;True\u0026rdquo; marks from the community, admits that they make an error and personally mark the Objection as True so that the community knows that the Objection has been acknowledged by the original creator.  In this case, Fireship could create a patch to that part of the video in response to the Objection and link to the original Objection to revert the \u0026ldquo;small error\u0026rdquo; label.    "},{"id":23,"href":"/docs/spec/applications/protocol-of-truth/protocol-of-truth/","title":"Protocol of Truth","section":"Docs","content":"Protocol of Truth #  This is a protocol of back and forth debate with the aim to evaluate the quality and truthfulness of content posted to the internet.\nIf you have ever seen a photoshopped post on social media, or a video citing a badly done study, this techno-social protocol aims to inform through discourse the truthfulness of a given piece of media to anyone who might come across it.\nThe outcomes of this protocol label specific pieces of content. Here are some potential labels:\n Truthful - Unobjectionably true False - Unobjectionably false  Benign - False, for comedy, or other reasons   Factful - Well researched argument with generally accepted sources Outdated - This might have been factful, but new information exists to provide alternative conclusions. Opinionated - Content that is not sourced Minority Opinion Missing Context   These labels are determined dynamically and are subject to change and dispution. The history of labels and the conversation around them are stored. Certain labels can only be applied on top of specific other labels.\nNew Objection Undecided\nCorrect Opinion\nIdeas #  Idea: Instead of people upvoting and downvoting a given flag, they flag the flag and provide more supporting details. All this back and forth flagging results in a kind of \u0026ldquo;tree of flags\u0026rdquo; from which what is true, what is false, and what is ambiguous can be extracted.\nScene: Someone posts a video, there is an error in the video, someone posts a correction in the comment with a relevant tag.\n"},{"id":24,"href":"/docs/spec/applications/protocol-of-truth/protocol-types/","title":"Protocol Types","section":"Docs","content":"Types of Labels for the Protocol of Truth #  The protocol of truth is a protocol for applying labels to pieces of content. There are a lot of things a piece of content can be generally and specifically.\nThere are various labels for content. These labels are called Types. They are typically split up into categories of Truths and Falses.\nTruths #  What is Truth? What Makes something True? Truth is the quality of being\nThere are many kinds and reasons for falsities, but there is only two types of truth: Absolute Truths and Researched Truths. Absolute truths are typically self-evident, while Researched Truths need to be sourced. This is why the Objections.\n Researched Truth  Absolute - Absolute truths (e.g. the sun comes up every day)\n Common - Truths that can be verified with a quick search (i.e. in 1998, The Undertaker threw Mankind off Hell In A Cell, and plummeted 16 ft through an announcer\u0026rsquo;s table.) Researched - Truths that result from a well-reviewed scientific study or observation (i.e. )  Falses #   Error - Category of falsities caused by error  Simple - Simple error Visual - Error in visual Tecnical - Error in technical details, bad math, bad labeling, bad graphs. Catastrophic - Error in a part of the concept as a whole.   Benign - Category of falisies  Comedy   Malignant - Category of falsities caused intentional disinformation.  Propaganda - Content Sponsored  State Corporate   Personal - general category for conflict of interest, (e.g. promoting something that you benefit from being promoted)   Misleading  Bad Context - Label for content that takes things out of context Bad Graphs - graphs which are technically correct but leave out core details. Bad Statistics - When statistics are done that are incorrect.     "},{"id":25,"href":"/docs/spec/applications/tree-of-math/","title":"Tree of Math","section":"Docs","content":"Tree of Math #  Defining all of math programatically using set theory.\nTraits #  Defining the fundamental structures of math:\n Variable  Math Def: An variable in an axiomatic system Struct Def: Uniquely identify a variable in a system Struct: { id: Varint }   Proposition  Math Def: A true or false statement based on a system of propositions Structure Def: A boolean value corresponding to a predicate statement on a proposition system. Struct: { system: Link\u0026lt;Proposition\u0026gt;, struct: Link\u0026lt;Predicate\u0026gt;, value: bool }  E.g.   Predicate  Math Def: Proposition-Valued function of some variables Structure Def: List of variables representing a function that can be used in a Definition Struct: { List\u0026lt;Variable\u0026gt; } Usage:   Operation  Math Def: A predicate constrained by various propositional statements to define a function in some Domain. Struct Def: Predicate and a proposition   Symbol  Struct Def: A Unicode symbol pertaining to some or various Operations.   Proof  A proof is just a list of propositions that results in prooving a proposition from some axioms. A proposition can be an Axiom, a Tautology, or a derived proposition. Valid Proofs that use Valid Axioms in Dither can themselves be treated as Axioms because they link directly to other proofs. Full Proofs can be compiled by traversing the Tree of Math (much like compiling C++ into assembly)    Roots #  The roots of Math\n"},{"id":26,"href":"/docs/spec/applications/user-proofs/verified-human/","title":"Verified Human","section":"Docs","content":"Verified Human Proof #  The Verified Human Proof is a built-in anti-spam and anti-bot system that works across Dither. It is a zero-knowledge proof for prooving one-sidedly that an account is indeed used by a human.\nThere are two types of verified human proofs: marked human, trusted human, unique human.\n A marked human signifies an account with human-like tendencies. A trusted human is an account that has a unique human fingerprint that can be traced across accounts. A unique human is an account marked that has been marked by a trusted 3rd party to be a verified human.  It is easy to get the marked human proof. You can do achieve it simply by using Dither\u0026rsquo;s social applications normally:\n Use Dither often enough to be flagged as human enough times by other verified humans (of either type).  To get the trusted human mark, you can get it by using and posting on Dither for a long time, or uploading distinct features.\n Become popular enough on Dither to create a profile that is flagged as human.  [WIP] To be prooved as a unique human, you must go to a 3rd party trusted by the community to verify humans.\n"},{"id":27,"href":"/docs/spec/copyright-is-cancer/","title":"Copyright Is Cancer","section":"Docs","content":"Why Copyright is Cancer #  Copyright is ineffective in the internet age. Any piece of content can be pirated on a massive scale without the original creator even knowing. The only thing copyright does is suppress derivative creation on forums with strict copyright adherence. See these videos on why the current copyright system is broken and why it makes no sense. This document outlines an alternate system of funding creation that Dither aims to create.\nHave a decentralized \u0026amp; democratized forum of communication and publication that no institution or individual can meaningfully obstruct. Dither is a protocol for creating decentralized applications.\nProvide a direct connection of support between the consumers and the creators allowing people to directly support creators for the content they produce ( Paying for Production, not Distribution). Even huge projects like Marvel movies or video games can be supported through community fundraising. Each production raises the reputation of the artist(s), allowing them to raise more money from their fans for the next project.\nPreventing artists from having control over their art allows all artists to use and adapt and recreate the work of other artists. Imagine all the games and movies that were super hyped up but totally flopped. If anyone was allowed to make anyone else\u0026rsquo;s work but better, artists have an incentive to make good stories so that they can raise money for their next project, instead of making something crappy and making all their money off of preorders. This would also prevent the fragmentation of distribution services as no one entity can have exclusive control over a piece of content.\n"},{"id":28,"href":"/docs/spec/dither/","title":"Dither","section":"Docs","content":"The Dither Project #    The Dither Project  What is it?   No, but really, What is it?  What\u0026rsquo;s this about replacing the Internet?  Potential Applications:    Core Tenets  Structure   Finding Data Links (Reverse Hash Lookup)  Dither Chain References  Dither Consensus Chains  WIP - Dither Weighted Voting  Inspiration    What is it? #  Dither is a project that aims to decentralize the internet! It is a toolbox of various tools application developers can use to store data, manage accounts, and communicate across the internet in a private manner.\nNo, but really, What is it? #  Dither is a modular application API built on top of Libp2p. It aims to provide buliding blocks for communication, data storage, account management, consensus and more to replace most online services with a decentralized and private alternatives.\nWhat\u0026rsquo;s this about replacing the Internet? #  Dither aims to replace most existing apps and services, however, some services are hard to replace without significant disruption because of their existing user and content base. To solve this, Dither will be able to act as a kind of interface with various services, pulling data from multiple sites and presenting it in a standardized way.\nIt aims to be compatible for extracting data from and interfacing with most existing decentralized and centralized systems such as IPFS, Github, Reddit, Youtube, Sci-Hub, Odysee \u0026amp; Discord. The aim for Dither is to replace these applications with decentralized alternatives that are unified through their use of a singular, modular protocol.\nPotential Applications: #  Chat/Communication Apps, Video Sharing, Social Media, Comment systems, File Synchronization, Encrypted Backup, Voting systems, Exchanges, Crowdfunding, VCS, Stores, Serverless Games, Remote Machine Control, etc.\nThe goal of Dither is to be able to recreate any kind of application in a decentralized manner.\nSee the application document for Work In Progress ideas for various applications.\nCore Tenets #  All projects need a direction, and these are the ones I\u0026rsquo;ve chosen. (As with everything, they are subject to change.)\nDither should be as modular as possible.\n There should be no part of Dither that is hard to replace with a different implementation.  Dither protocols and formats should be able to interoperate with most other protocols and formats.\n One example of this would be allowing someone to pull comments from Reddit / Youtube into Dithca and hosting them in a decentralized manner. Another example might be Dithca storing Reddit credentials and being able to optionally interact with comment threads pulled from centralized websites.  Dither should rely on itself as much as possible for every aspect of development and usage.\n Code Versioning, Storage, Building, Distribution, and Communication should all run through Dither as much as possible.  Structure #  Dither is structured in layers:\n Network Layer (Provided by libp2p)  Handles peer-to-peer connections (NAT Traversal, Muxing, MDNS Discovery). See libp2p.io   Core Layer  Routing Module   Distance-Based Routing: Custom onion routing protocol which allows for anonymity on the network and is faster and more flexible compared to random routing (like what TOR and I2P uses)   Encryption  Using multikey for asymmetric encryption or decentralized kerberos for solely symmetric encryption.   Data Structuring \u0026amp; Manipulation ( Hashtypes) Data Searching ( Directional Trail Search) Data Linking ( Reverse Hash Lookup) Consensus Algorithms ( Distance Aware Consensus) User Sync \u0026amp; Authentication ( User Management)   Application Layer  Uses some or all of Dither\u0026rsquo;s features to create an application API There is a list of potential applications for dither and various work-in-progress API definitions.   UI Layer  This is the actual UI and design portion of applications. It takes the functions provided by the Application Layer and implements them according to the creator\u0026rsquo;s desires. It is highly recommended to follow Dither\u0026rsquo;s application design philosophy when designing UI apps.    More Info in the Directional Trail Search Document.\nFinding Data Links (Reverse Hash Lookup) #   This solves the problem of having a hash and wanting to find pieces of data that link to that hash. This is super useful for comment systems and the like. This is a system by which one can find structures that link to a given hash implementing the reverse trait. If there is some pieces of data that links from or adds useful definitions to a given piece of data, this is the place for it. One example of this in practice might be having a comment thread. Each comment is its own Hashtype that contains the hash of the post or a replying comment. In order for someone who has the post structure to find the comments, they would need find all the pieces of data linking to this piece of data (i.e. a Reverse Hash Lookup) To implement this system, there will be a partial binary tree represented by a DAG that can be traversed using the data of the target. (i.e. the post structure\u0026rsquo;s hash). Then the tree can be traversed down using consecutive trail searches. Until a list of all known linked hashes is found. These structures must contain a specific trait called a RevHash to be able to be validated onto the distributed tree. The addition of new links to this tree is done through an implementation of Dither Chain Consensus (see the #Dither Consensus Chains section).  See User Api Document\nDither Chain References #  Ideas for Dither Consensus\n IOTA Tangle Stellar Consensus Protocol zk-STARKS (for privacy) Layered on top of Dither Gravity Tree Search for storage  Dither Consensus Chains #   Regular Chains  A chain is created just by linking to one or more other Hashtypes (fundamental format of Dither objects) Regular Chains can be used to represent filesystems, linked data, pretty much anything.   Consensus chains are different in that blocks linking to other blocks are weighted by how much they are linked to themselves. (Like the IOTA tangle) Blocks are added via \u0026ldquo;active consensus\u0026rdquo;, where new blocks are broadcast to computers actively participating in consensus and organized / verified using the Stellar Consensus Protocol.  This could be used for a comment system where the comments with the most upvotes / interactions are sorted higher in a specific index.   Quorum slices in the SC protocol will be made up of social friends or other trusted users. (which can be registered by applications using Dither in specific contexts i.e. close friends in Dither Chat could be designated as part of a core Quorum Slice) Quorum Slices will be stored in the trusted user configuration Small “Consensus Chains” can be publicly listed or privately created between specific users with special rules on how blocks are added  WIP - Dither Weighted Voting #   Using Dither Consensus as a backend Creates Consensus Chains between users to vote on a specific thing Can be used for copyright reporting, community information addition, data validation, etc. Structure: Main definition Who created it  Inspiration #  It is much inspired by and takes from various projects such as Rust, TOR, Bittorrent, IPFS, IPLD, Stellar, Ethereum, IOTA, Monero, zk-STARKS, and more.\n"},{"id":29,"href":"/docs/spec/dither/application-design-philosophy/","title":"Application Design Philosophy","section":"Docs","content":"Application Design Philosophy #  Application APIs should be future-proofed as much as possible\nApplication GUIs should be generally be as cross platform as possible.\nThere should be different modes of use for different user skill levels to try and accomidate as many people as possible.\n These modes should enable/disable various aspects of configurability in the application Simple mode should be super easy to use for anyone and come with a quick tutorial  Configuration options should be assumed as much as possible,   Default mode should come with a tutorial and explain how modes work and how to change them Advanced mode assumes the user already knows how to use the app or can figure it out on their own. All configurability functionality should be enabled.  Application developers should strive to implement as much configurability as possible into every aspect of their application for complex users. For desktop applications, configuration on a small level (for specific contextual buttons or features) could be shown through right-click menus. For mobile applications these configuration items can be shown through a long-press.    "},{"id":30,"href":"/docs/spec/dither/consensus/byzantine-federated-voting/","title":"Byzantine Federated Voting","section":"Docs","content":"Byzantine Federated Voting #  TLDR: https://www.scs.stanford.edu/~dm/blog/simplified-scp.html\nThis will be used as an optional alternative to\n"},{"id":31,"href":"/docs/spec/dither/consensus/consensus-algorithms/","title":"Consensus Algorithms","section":"Docs","content":"Consensus Ideas #  List of various consensus algorithms' pros \u0026amp; cons that could be utilized by Dither for different applications\n Proof of Work  Cons  Very inefficient \u0026amp; slow (transactions take multiple minutes or more to verify) Uses a lot of energy Causes avenue of abuse for malware crypto miners Requires sufficient size of network to be trusted Large storage requirements for full node Miners congregate into centralized pools Slowness pushes to centralization   Pros  Simple to understand, easy to implement Easy     Proof of Stake  Cons  Only works for cryptocurrencies (need staking incentive) Faster than proof of work Large storage requirements for full node   Pros  Faster and more energy efficient than proof of stake     Proof of Weight  General term to describe systems that work similarly to Proof of Stake, where there is some shared value that determines how   Stellar Consensus Protocol (Byzantine Federated Voting)  Cons  Large storage requirements for full node Uncertain consensus (health of network slices can\u0026rsquo;t be judged) Tendency towards centralization Lots of packets   Pros  ~5 seconds / transaction, extremely low transaction fees Can be integrated with social media to reflect IRL social connections as quorum slices.     Nano Consensus Protocol  Cons  More ways to compromise network, no reward for running nodes Potential DDOS vectors with transaction flooding. Low scalability for representatives (can\u0026rsquo;t support millions of representatives voting at the same time)   Pros  Really fast (\u0026lt;1 second transactions if no conflict), no transaction fees.     IOTA Consensus Protocol  Cons  Potential attacks due to adversaries with 33% of network hashing power Requires centralized coordination node until the network reaches a certain size Requires periodic counting of tangle to eliminate history.   Pros  Really fast, No transaction fees Very good scalability due to probabilistic consensus algorithm     Hedera Hashgraph  Cons  Potentially large storage requirements Very centralized (nodes have to be registered with a central entity) 1/3 attack Consensus depends on network knowing the number of total nodes Doesn\u0026rsquo;t scale very well   Pros  Pretty fast (as fast as Stellar Consensus Protocol) Hashgraph is interesting concept      Dither Distance-Aware Consensus (WIP)  Pros  Transaction speed is faster the closer the wallets are to each other in the network. (Sub second times for close nodes) Negligent storage \u0026amp; computational requirements for full node Localized Transactions (i.e. someone on the other side of the world doesn\u0026rsquo;t have a record of your transaction). Network   Cons  Potential loss of ownership of funds if enough nodes in a certain area go down (mitigated by distributing funds or slower, backup consensus algorithm) It\u0026rsquo;s a work in progress.      "},{"id":32,"href":"/docs/spec/dither/consensus/distance-aware-consensus/","title":"Distance Aware Consensus","section":"Docs","content":"Area-Aware Consensus #  Why Area-Aware? Information takes time to travel and sometimes consensus only needs to be done in a local manner. With plans for colonies on other planets within decades, consensus algorithms that are aware of the time it takes for information to travel and don\u0026rsquo;t require the consensus of all the computers in the network will be invaluable.\nIdeas #  Tiered Consensus #  Create tiered layers of consensus at different scales that cover different numbers of people, each high layer covering more people and being slower than the last.\nImagine a cryptocurrency that serves the people in City A. To make a transaction in this city, each person must have the few hundred people running consensus nodes in the city come to consensus on the order and validity of the transaction. This would be very fast because it is on a local level with only a few hundred nodes participating in the consensus protocol.\nNow what if someone in City A wanted to send money to a resident of City B? Well, each city\u0026rsquo;s consensus network keeps track of the total amount of money in the wallets of the city\u0026rsquo;s residents. When a transaction between cities is required, the local consensus computers of the city will communicate\nWhat if we could create a tiered layer of consensus that takes into account how fast information travels and can account for different items of consensus being needed at different scales. For example, for a cryptocurrency each city could have its own consensus network, and only when transactions are going outside the city will the city\u0026rsquo;s consensus network need to communicate and create consensus with other city\u0026rsquo;s consensus networks. This tiered system could even be expanded to interplanetary transactions making it really efficient to send money to other planets, no requiring whole planets of computers to create consensus with each other, or expensive exchanges.\nConsensus Networks act as peers themselves and establish\nPer Argument Consensus #  Another idea might be Argument-based consensus. This type of consensus only makes computers who are near to the named relevant parties (and areas) of the network subject to consensus. For example, if Alice wants to transact with Bob, this requires Alice\u0026rsquo;s \u0026ldquo;network neighborhood\u0026rdquo; to verify that Alice has money to spend, and it requires Bob\u0026rsquo;s neighborhood to take note of the new money Bob has.\nDownsides #  The main problem with Area-Aware consensus is that money is stuck in a specific area. This can be overcome by divvying up your money into wallets in different places or simply waiting for the transfer.\n"},{"id":33,"href":"/docs/spec/dither/consensus/eventual-consensus/","title":"Eventual Consensus","section":"Docs","content":"Eventual Consensus #  What? #  Eventual Consensus is not quite what it sounds like. It is consensus in a network that is lazy. This is useful for public information spreading where not everyone has to have the information in a timely fasion.\nWhy? #  For consensus applications that don\u0026rsquo;t have a timeline (blockchains and directed acyclic graphs) this method of consensus is useful because it lets nodes kinda do their own thing if they aren\u0026rsquo;t interested in what is being spread around the network in a given moment. For example if you have a public message board, you need only to notify users that care about the message board and want to see new messages. Those users can propagate the new messages around to other requesters if needed.\nBut why is this useful in Dither? #  The Reverse Hash Lookup system will benefit immensely from this kind of consensus. Reverse hash lookup\nGeneral Structure #  Its pretty much just a pubsub algorithm that aggregates posts into lookup trees like Reverse hash lookup\u0026rsquo;s object tree.\n"},{"id":34,"href":"/docs/spec/dither/consensus/modular-consensus/","title":"Modular Consensus","section":"Docs","content":"Modular Consensus (WIP) #  What is it #  Modular Consensus is a tool that creates a framework for creating any configuration of common consensus algorithms for specific applications.\nWhat does it do? #  Modular Consensus allows you to create custom consensus configurations using linked blockchain or directed acyclic graphs with most(?) kinds of proof algorithm (Proof of Work, Proof of Stake, Etc.).\nHow does it specifically work? #  Modular consensus uses a specific hashtype to define the main characteritics and configuration of a consensus algorithm (onboarding method, consensus algorithm, data to be agreed upon).\nConsensus algorithms can make use of the built-in validation system for hashtypes to verify blocks.\nImplementation #  A type must extend the, ConsensusPoint type which will become valid as the starting point for consensus. The ConsensusPoint type defines many things:\n[This Section is Work-In-Progress]\nConsensusPoint:\n consensus_type: ConsensusType object: Link\u0026lt;Trait\u0026gt; - Object to be agreed upon ``  "},{"id":35,"href":"/docs/spec/dither/data/hashtypes/core-traits/","title":"Core Traits","section":"Docs","content":"Core Traits #  This document contains a list of Core Traits for the self-defining structures system.\nMultihash: Hash of some data.\n Sized: Dynamically sized Valid: Valid if follows the multihash format.  Trait: Structure of a Trait definition\n Sized: Dynamically Sized  "},{"id":36,"href":"/docs/spec/dither/data/hashtypes/hashtypes-old-old/","title":"Hashtypes Old Old","section":"Docs","content":"Self-Defining Structures #  (A.k.a. Hashtypes)\nSelf defining structures are pieces of data that link to their own format, telling the program how they are structured and how to validate them.\nThe workings of this system are heavily dependent on Directional Trail Search and Reverse Hash Lookup.\nIdeas To Add to this Doc #   Make structures' fields binary-ordered by default to increase the chances that developers will use and create the same structures. Delegate conceptual ordering to TraitLocalization.  I.e. if two programs both need a File trait and a file is just some binary data and a creation date, the resulting File trait will be the same in both programs assuming the programmers use the same internal fields.    Structures #  A structure is a piece of binary data that starts with a Multihash. A structure is considered correct if the format of the binary data corresponds with the Trait definition linked to via the Multihash.\nTraits #  Traits are what the formats of self-defining structures are called and are themselves structures defined by their own trait. This allows the creation of any type of structure imaginable.\nMarkers #  Markers are the core primitives for adding functionality to structures. They mark the interface between the Hashtrait implementation and the data of a structure. They tell the implementation what operations a program can perform on a given structure as well as how the data should be interpreted at a base level.\nMarkers are recognized by the program as the sha256-variant multihash counting up from 0. They do not correspond to the hash of specific data. (i.e. the base58 encoding of TraitMarker would be QmNLei78zWmzUdbeRB3CiUfAizWUrbeeZh5K1rhAQKCh51 and MultihashMarker would be QmNLei78zWmzUdbeRB3CiUfAizWUrbeeZh5K1rhAQKCh52)\nPrimitive Markers:\n TraitMarker - Marks a structure that acts as a trait. Also acts as a base trait implementation. Allows for implementation to interpret basic trait definitions as well as marking custom traits.  Trait Format: \u0026lt;0x000 hash\u0026gt;\u0026lt;varint length\u0026gt;\u0026lt;list of \u0026gt;   MultihashMarker - Marks a multihash. Interpreted by implementation as a sha-256 multihash as defined by the multihash specification. SizeMarker - Allows the program to know beforehand the size of a structure.  Advanced Markers: (WIP)\n GenericMarker - Marks generic arguments of a trait. DynamicSizeMarker - Marks a structure size calculation program. Allows for the implementation to derive the size of a specific structure. ValidityMarker - Marks a structure validation program. Allows for implementation to check if a structure is defined correctly as defined by its trait.  TraitMarker Implementation #  The TraitMarker trait is defined in implementation as a trait like this:\n TraitMarker  SizeMarker - Represents the size of the defined structure MultihashMarker - MultihashMarker    Primitive Trait Implementations #  Notice: These trait definitions will have named fields, in actuality, field names are defined through a reverse-linked trait called a TraitLocalization and can be defined in multiple languages.\nFrom Markers, primitive traits can be created. A simple trait could be defined as:\nTrait: TraitMarker (The \u0026ldquo;:\u0026rdquo; represents that the Trait structure is being defined in terms of the TraitMarker \u0026ldquo;structure\u0026rdquo;)\n fields: List\u0026lt;\u0026gt;  Traits can also be generic across other traits to apply some functionality (Such as the Multihash, Option, List, or Collection traits).\nEach trait is itself a structure and also starts with a multihash and has it\u0026rsquo;s own format.\nA typical trait will use the Trait type as it\u0026rsquo;s format which is defined as the following:\n extension: Option\u0026lt;Multihash\u0026lt;ext Trait\u0026gt;\u0026gt; (Optionally specify trait that is being extended) (List of Multihashes that link to objects which extend Trait)  The Trait type as well as all other built-in types are identified by a multihash of their name. i.e. \u0026ldquo;Trait\u0026rdquo;.\nThis leads to the second feature of traits which is extension. Traits that extend other traits simply add fields to the resulting structure that is defined.\nCommon Trait Types #  Built-in #  These are the minimum viable Traits needed to define all other Traits. Some of these traits will be redefined to support various features and to ensure future-proofing.\n VarUInt - Multiformat\u0026rsquo;s Variable-Length Integer Multihash - Formatted via the Multihash format, defines a hash generated by a built-in table. Byte - 8-bit piece of data. List\u0026lt;T, L: VarUInt\u0026gt;(L) - Create lists of a certain type, length must be of Trait VarInt CoreTrait - Core definition of a trait. It is defined in the implementation, but is essentially a List of Multihashs.  Core (Re)Defined Traits #  The core traits are needed to compose all other traits. But all the features of self-defining structures don\u0026rsquo;t arise from them directly.\nThe concept of \u0026ldquo;Structure Validity\u0026rdquo; is important. An Enum object is just an integer, but it shouldn\u0026rsquo;t be larger than the number of Enumerations. A Enum structure that contains a value larger than its definition is considered invalid, even though it may be interpretated correctly.\n String: CoreTrait  bytes: List\u0026lt;Byte\u0026gt;(L)   Trait: CoreTrait  name: String fields: List\u0026lt;Multihash, L\u0026gt;(L)     Defined Traits #   Enum\u0026lt;T: VarUInt, L: T\u0026gt;: NamedTrait - Defines a number that correspond to different states of the Enum. Number of Variants in Generic  variant: T validity: Validity - Enum is only valid if the type T is an unsigned type, it is large enough to fit L, and variant is less than T.   BitFlag\u0026lt;L: UInt8\u0026gt;: NamedTrait - Defines a series of bitflags up to Link\u0026lt;T\u0026gt;: VersionedTrait - Multihash linking to structure with specific Trait T.  hash: Multihash link_type: LinkType  LinkType: Bitflags\u0026lt;1\u0026gt; - Provides metadata about the importance of the lined object. Governs whether or not linked data is garbage collected, sent to requesting devices with the original request, or stored in a specific way.  Embedded - Linked object is absolutely needed by the original structure (should be relatively small). Cached - Linked object that is absolutely needed but the requesting device should already have (i.e. emojis, fonts, trait definitions, etc.). Needed - Linked object that should probably be sent back ASAP. Relevent - Linked object that is relevant to the structure but not necessarily needed ASAP (e.g. image or linked video file) Irrelevant - Linked object that is large or unecessary and should never be sent with original request.       RevLink\u0026lt;T\u0026gt; - Wraps a Link\u0026lt;T\u0026gt; and requires a Trait type specification. Registers the trait T in the Reverse Hash Lookup tree. Allows for lookup of trait containing RevLink\u0026lt;T\u0026gt; type from the hash linked to.  link: Link\u0026lt;T\u0026gt; validity: Validation   Localization: Enum TraitLocalization: NamedTrait - Defines field names and overall name of RevLinked trait in different languages.  name: String fields: List\u0026lt;String\u0026gt;     Trait Variants #  List of Traits that extend the core Trait type.\n NamedTrait: Trait type which contains a String for the English name of the Trait. VersionedTrait: NamedTrait - adds Option\u0026lt;RevLink\u0026lt;ext VersionedTrait\u0026gt;\u0026gt;\u0026gt;. This is useful for backwards-compatability and future-proofing.  Link Strengths #  Being able to specify how vital a linked piece of data is to the \u0026ldquo;owning\u0026rdquo; piece of data is desireable when requesting data so that too much or too little is sent and either data has to be disgarded or more data has to be requested. For example, if a structure is defined to format a piece of data that is not self-defining, it is desirable to be able to specify to fetch only the structure itself, or the structure together with the embedded data. To accomplish this,\nFrom Dither.md #  Defining External Structures #  In Dither, while pieces of data can be located and linked with multihashes, not all pieces of data contain multihashes. Any external hash-linked data structure that you want to host on Dither (i.e. blockchains) aren\u0026rsquo;t going to be natively supported. Instead all the blocks of data must either be re-linked to form a multihash-supporting copy or the hash types have to be inferred by context. (The downside of the second option non-hashtrait blocks can\u0026rsquo;t easily be inferred from non-specific programs interpreting hashtraits). The second option is what IPFS/IPLD is doing, reinterpreting hashed blocks of data of arbitrary format by defining a standard table of formats. Dither prefers the first option of wrapping the entire data structure with trait definitions that Dither can understand.\nWhat IPLD does is it uses an addition to Multihash called CID (Content Identifier). This CID contains both the multihash and a number for the Multiformats table that must be standardly designed.\nThe problem with IPLD is that this standard table of formats is subject to change. Formats are not universal and if you want to identify custom formats not in the table, you are out of luck if you want to communicate your custom formats to existing IPFS applications\nWith Dither, instead of having a hard standard list of formats, Formats of data are defined by the data itself using the hashtrait format. Data that is not trait-defined, will be either wrapped using a definition trait (i.e. a structure just containing a hash of the data and trait). Or it will be reinterpreted to be represented natively as a trait structure.\nExample Traits #  Traits can define any data structure and its state of being \u0026ldquo;Valid\u0026rdquo;. A Monero Transaction might look something like this after being structured in Dither.\n \u0026quot;Transaction\u0026quot; (With localization fields)  previous_transaction: SelfRef definintion: Multihash (Default Trait Definition) source: List\u0026lt;MultiKey\u0026gt; destination: Multikey pederson_commitment: PedersonCommitment signature: RingSignature    "},{"id":37,"href":"/docs/spec/dither/data/hashtypes/hashtypes-old/","title":"Hashtypes Old","section":"Docs","content":"Idea Document for Hashtypes #  What is a Hashtype #  Generally, A hashtype is a piece of data, prepended by a Multihash. The multihash can be resolved using directional-trail-search to some data that defines the layout of the hashtype.\nA type definition (seen below) contains a type name, multiple fields, and a type for each field. The most primitive type definition (Layout) allows for the creation of dependent types.\nWhat constitutes a Layout? #  All Types are all eventually defined by the core Layout type.\nThe core Layout type is defined in implementation roughly as:\nLayout\n num_fields: B8 - Binary 8-bit number num_traits: B8 hash_length: VarUInt - Variable unsigned integer hash_type: VarUInt fields: Unknown - Variable length data traits: Unknown $FixedSize = undefined - It doesn\u0026rsquo;t matter what this is because $Size doesn\u0026rsquo;t use it for this type. $Size: $FixedSize = (self) -\u0026gt; U64  num_fields.size() + hash_length.size() + hash_type.size() + num_fields.to_u64() * hash_length.to_u64() Defined as function that takes a reference to the beginning of a buffer containing a value of type Layout and returns 64-bit integer. Depends on $FixedSize. Fixed-size types return $FixedSize. Variable-length types calculate size dynamically.   $Correct: $Size = (self, size) -\u0026gt; bool  (size == $Size(self)) \u0026amp; num_fields.correct() \u0026amp; hash_length.correct() \u0026amp; hash_type.correct() Dependent Trait, relies on $Size. Returns true if Unknown data field is correct size and the VarUInts are also correctly formatted.   $Valid: $Correct = (self, size) -\u0026gt; bool  { $Correct(self, size) \u0026amp; num_fields.valid() \u0026amp; hash_length.valid() \u0026amp; hash_type.valid() \u0026amp; [logic to verify hash-linked objects validity contained in data field] }    See Traits for an explanation of $ notation.\nThis also infers the interpretation of VarUInt and Unknown.\nVarUInt - A VarUInt is just a Variable Unsigned Integer\n data: Unknown $Size: $FixedSize = (self) -\u0026gt; U64: [varint size algorithm] $Correct: $Size = (self, size) -\u0026gt; bool  The Unknown type just refers to raw data that is defined via the $Size and $Correct Traits.\nTraits #  Traits define programs or adjacent data on Types. They are themselves Hashtypes linked directly from the layout type or via reverse linked data.\nTrait: Layout - A Trait is a type that defines multiple functions #   $Size: $FixedSize = (self) -\u0026gt; U64: type.size() $Correct: $Size = (self, size) -\u0026gt; U64  LinkedTrait - Trait that is reverse-linked\nFunction - A program is an input and an output\n input: Multihash output: Multihash  Implementation - Implementation of a program\n program: Multihash - Program Layout Multihash type: VarUInt - Program Type (CPU Arch) impl: Unknown - Program Data (Machine Code)  All types should have the $Correct trait definitions (This implies $Size and $FixedSize)\n$Size is described as a U64 or Reference -\u0026gt; U64.\n$Correct takes a reference to a point in memory where a Typed value is and returns true if the\n"},{"id":38,"href":"/docs/spec/dither/data/hashtypes/hashtypes/","title":"Hashtypes","section":"Docs","content":"Hashtypes #  Hash types are how Dither deals with data.\nA fundamental property of hash types are that they describe their own domain. This includes: what data types make up the domain (i.e. bytes, types, other data types) and how those datatypes may be restricted (i.e. a data type might be variable in length depending on another type like a list).\nFundamental Types #  There are a few fundamental types.\nMultihash type #  Expr type #  Reflects Lambda Calculus\nExpr can be interpreted as 3 things:\nBind Variant: (Varint)\nLambda Variant: (Multihash\u0026lt;Expr\u0026gt;, Multihash\u0026lt;Expr\u0026gt;)\nApplication Variant:\nType type #  ` #  "},{"id":39,"href":"/docs/spec/dither/data/hashtypes/lambda-calculus/","title":"Lambda Calculus","section":"Docs","content":"Lambda Calculus #  Idea - Lambda calculus to represent types\nRepresentation #  Representation of Lambda expressions in Hashtypes\nLambda Tree representation #  There are 4 parts to this hashtype representation.\n Variable - Multihash cast to 0  Represents a variable (unknown whether it is bound or unbound)   Lambda - Multihash cast to 1  \u0026lt;VarUInt\u0026gt;\u0026lt;Bits\u0026gt;\u0026lt;Multihash\u0026gt;  \u0026lt;VarUInt\u0026gt;\u0026lt;Bits\u0026gt; represents a list of variable-length bit-arrays, each bit of the array represents which a direction (left or right) which should be traversed down when encountering an Application expression     Application - Multihash cast to 2  \u0026lt;Multihash\u0026gt;\u0026lt;Multihash\u0026gt;   Select - Multihash cast to 3  \u0026lt;Multihash\u0026gt;\u0026lt;Multihash\u0026gt; Represents waiting on 2 operations and returning them in order of completion. Group 2 expressions, returns expressions in order of which one returns first. (for parallel programming)  Application(Application(And, func_loop), func_false) = func_loop Application(And, Select(func_loop, func_false) = func_false      Cons - lots of re-hashing needed for beta \u0026amp; eta reduction - probably not a real problem\nPros - Code is very deduplicated\nWeird Idea about computation\u0026hellip; #  Multiplication is O(N log(N)) at the fastest, but the \u0026ldquo;typical\u0026rdquo; algorithm run in O(N^2). These algorithms can be represented using a so-called \u0026ldquo;parallel reduction lambda calculus\u0026rdquo;. Is there some relation between these two representations? Perhaps beta and eta reduction can derive one from the other?\n"},{"id":40,"href":"/docs/spec/dither/data/hashtypes/primitive-traits/","title":"Primitive Traits","section":"Docs","content":"Common Primitives for Self-Defining Structures #  These primitive types are defined by the implementation of Dither. They can be identified through hashes that count up from 0.\nFor more detailed explanations see the hashtypes document\nVarUInt - Dynamically sized unsigned integer\nLayout - Layout for defining structures\nUnknown - Dynamically sized unknown data (defined by wrapper types with Traits)\nTrait - Reverse-Linked trait that defines inputs and outputs for a program implementation\nProgram\n"},{"id":41,"href":"/docs/spec/dither/data/hashtypes/self-verifying-structures/","title":"Self Verifying Structures","section":"Docs","content":"Self-Verifying Structures #  "},{"id":42,"href":"/docs/spec/dither/data/proof-of-linked-data/","title":"Proof of Linked Data","section":"Docs","content":"Proof of Linked Data #  The idea behind proof of linked data is that if you have the hash of a hashtype. You can prove things about that hashtype.\nThe behind proof of linked data is asking the question: \u0026ldquo;prove that when function x is applied to the data that generates hash y, results in z\u0026rdquo;.\nPotential applications of this simple concept are endless:\n put burden of proof on the creater of the object. is the linked type of type \u0026lt;insert type here\u0026gt;? is linked hashtype correct and valid? are the hashtypes linked to from linked hashtype correct \u0026amp; valid? is the hashtype linked to signed by public key x? does the linked hashtype eventually link to hash x?  Now, I\u0026rsquo;m not entirely sure if all these applications are even possible, but zero knowledge proofs should allow for some of these applications.\n"},{"id":43,"href":"/docs/spec/dither/data/reverse-hash-lookup/","title":"Reverse Hash Lookup","section":"Docs","content":"Reverse Hash Lookup (WIP) #  Allows for finding what structures link to a given structure.\nExample: Someone can find a comment that links to a post, just given the hash of the post.\nIDEAS TO ADD #  Keep track of the number of child nodes for each node in the tree so you can merge reverse hash lookup trees easily in a peer-to-peer fashion which means consensus can be less rigourous.\nGeneral Structure #  A binary hash-linked search tree stored in a decentralized fashion with DTS that maps a given hash to object that contains that hash. Hashes are agreed upon in a decentralized manner, but direct consensus is assured, and a pubsub system helps speed up consensus for high-activity hashes.\nSpecific Structure #  Tree #   The goal for this tree is for nodes to contain as little information as possible so that large portions of the tree can be sent at once. A Binary Tree contains Branches and Nodes. For this structure, each one will be its own self-defining structure. Each node will contain Binary Tree, contains  Traits #    Node\u0026lt;T, L\u0026gt; - Nodes of the tree\n subnodes: List\u0026lt;T, L\u0026gt; - subnodes of this node    Leaf -\n  This is a system by which one can find structures that link to a given hash implementing the reverse trait.\n  If there is some pieces of data that links from or adds useful defintions to a given piece of data, this is the place for it. One example of this in practice might be having a comment thread. Each comment is its own Hashstruct that contains the hash of the post or a replying comment. In order for someone who has the post structure to find the comments, they would need find all the pieces of data linking to this piece of data (i.e. a Reverse Hash Lookup)\n  To implement this system, there will be a partial binary tree represented by a DAG that can be traversed using the data of the target. (i.e. the post structure\u0026rsquo;s hash). Then the tree can be traversed down using consecutive trail searches. Until a list of all known linked hashes is found. These structures must contain a specific trait called a RevHash to be able to be validated onto the distributed tree. The addition of new links to this tree is done through an implementation of Dither Chain Consensus (see the #Dither Consensus Chains section).\n  "},{"id":44,"href":"/docs/spec/dither/data/user-management/","title":"User Management","section":"Docs","content":"Dither\u0026rsquo;s User API #  Purpose #  Dither is aiming to replace the internet, so it needs a standard method of accounting. This includes storing user data publicly and privately, identifying users, and authenticating users. These accounts need to be able work across devices and should have varying levels of authentication for varying levels of storage of information. Dither accounts should also be able to prove qualities about themselves to external parties using zero-knowledge proofs.\nGoals #  Accounts should be able to be accessed in a standard way that is accessible to any application.\nAccounts should have multiple levels of authentication for varying levels of access to information.\nAccounts should be able to expose however much information their users want.\n Whether it be a throwaway anonymous account or an account connected to every aspect of a person\u0026rsquo;s life.  Structure #  A user is just a Public / Private key pair with encrypted and unencrypted data stored in a versioned data structure.\nThere are two parts to this datastructure, a public versioned structure and a private encrypted structure. The public key is stored in the public structure, the private key is stored in the private structure.\nAny interaction between an application and a user on Dither is done through the Dither API. Applications can create users, authenticate as a user and discover the public data of other users through the User API.\nUser Definitions #  These public and private structures can have various definitions that define various qualities about the user. Definitions are just permissioned data that is stored by a user. Definitions can be publicly available, publicly writable or conditionally available, and writable with specific permissions.\nExamples of Definitions #   Public  Username Autobiography   Private  User API #  Application\n CreateUser()  Create new user (for permanent or temporary purposes) This will create a new user in this peer and give access to application that called this DitherAction   Bootstrap(PeerID, MultiAddr)  Tell network layer to bootstrap to specific node (only used on startup)   Discover(UserId)  Initiate a network tree request to discover info about a user. (e.g. hosting peers, public configuration) Depending on the queried user’s config information may or may not be returned.   Authenticate(UserId, UserToken) - Authenticate to user on dither network  This will attempt to authenticate an application as a user on the network. When a token is sent to the peer(s) with permission over the user’s private key, the type of authentication is predetermined by the permissions in the private user configuration. The Types of Authentication are:  Hosting - the user’s private key is sent to the application and the application has full control over the user Proxy - all events are sent through peers with actual permission to sign messages   Will attempt to authenticate as a known user with known hosting peer   SendData(UserId, Data)  Send data to specific application of specific UserId Can potentially be a local application (such as dither-scp or dither-db) Or another dither service running on another peer    "},{"id":45,"href":"/docs/spec/dither/data/zero-knowledge-proofs/","title":"Zero Knowledge Proofs","section":"Docs","content":"Zero Knowledge Proofs #  These are really cool btw.\nPotential Applications:\n Anonymous Transactions Proof of Karma (proove that someone is trustworthy enough on the Dither network for them to be trusted without giving away more information than necessary) KYC/18+ requirements - For abiding by laws. (Is this even possible?) - Proove that some well-defined operation was done correctly on a given piece of data, i.e. that a binary was compiled correctly with no tampering. Prooving that a given Self-Defined Structure\u0026rsquo;s valid proof is valid. Anonymous Auctions (Hiding what other people bid for items)  Potential Traits: ``\n"},{"id":46,"href":"/docs/spec/dither/encryption/decentralized-kerberos/","title":"Decentralized Kerberos","section":"Docs","content":"Decentralized Kerberos #  Inspired by Kerberos authentication, by which every peer has a semi-permanent symmetric key (password) with a central server which then calculates one-time keys to establish encrypted connections to specific requested devices on a network.\nAwesome Computerphile video: https://www.youtube.com/watch?v=qW361k3-BtU\nIdea #  Decentralized kerberos removes the idea of a centralized server and instead establishes a direct symmetric connection to the desired peer by finding various peers near it an asking them for all act as a key authentication intermediary. Once a threshold of peers is met for enough different peers where it is unlikely that all the peers are controlled by one entity, the symmetric keys gained from each peer can be sent in one packet to the target node and combined to create a shared symmetric key.\nIf the desired peer to connect to is far away from the requesting peer, the peer can induce a recursive process to use the above algorithm to establish connections with closer and closer peers to the destination peer. Viable peers can be tested by requesting\nProcess #   Bob is remote peer. Alice wants to establish an encrypted connection with Bob using Decentralized Kerberos Authentication (DKA) instead of Public-Key Authentication (PKA). Both Alice and Bob have many peers that have established symmetric keys. Those peers have many other peers themselves and there are many paths of peers with encrypted tunnels to each other from Alice to Bob. Alice sends a traversal packet using DBR targeting routing coordinates randomly distributed around Bob\u0026rsquo;s routing coords. She then, still through traversal packets, queries whether those peers have direct connections to Bob. She continues until she has a certain threshold of peers which have direct symmetric connections to Bob. Again through traversal packets, she requests those peers to send back Kerberos authentication packets (i.e. packets that contain the requested symmetric key signed with a peer\u0026rsquo;s symmetric key)  "},{"id":47,"href":"/docs/spec/dither/encryption/multikey/","title":"Multikey","section":"Docs","content":"Multikey #  (WIP)\nData structure for representing encryption keys of any type and providing the algorithms to encrypt arbitrary data.\nMultikey\n key_type: VarUInt length: VarUInt data: Unknown $Size = [default implementation]   "},{"id":48,"href":"/docs/spec/dither/routing/directional-trail-search/","title":"Directional Trail Search","section":"Docs","content":"Directional Trail Search #  Allows for a computer to fetch a piece of data from another computer based on the multihash of that piece of data, as long as at least one computer has the data.\nGeneral Structure #  Directional Trail Search takes inspiration for how ants find food: scent and pheromone trails. In Dither, these take form as \u0026ldquo;holes\u0026rdquo; and \u0026ldquo;trails\u0026rdquo;. Holes form when nodes broadcast to nearby nodes (nearby in terms of routing coordinates) that they have the data behind a given hash. Those nearby nodes will then note down the hash and which direction the broadcast came from. Then, when another node wants to find the data of that hash, it will send out many wandering packets [link needed] that will, when encountering a node that has the desired hash, will be routed by that node towards the node that actually has the data that generates the hash.\nThe other form is \u0026ldquo;trails\u0026rdquo;. These form once a wandering packet has finally reached the node with the data it was looking for (the data the matches the hash). This destination node then sends a special traversal packet back to the sending node that tells each node on the way to take note of what direction the traversal packet came from. This forms a kind of trail in the network that other wandering packets can come across and follow to the desired node. This system also creates an effect where the more popular a given piece of data is, the faster a node hosting it will be found.\nFor data that is not very popular and can\u0026rsquo;t be find found with a reasonable number of wandering packets, a simple DHT can be used to map hashes to route coordinates.\nSpecific Structure #  Every node in Dither will have a binary tree structure that maps hashes to a relative routing direction or a direct peer (TBD).\nDownsides #  While Directional Trail Search is much faster and more efficient than DHTs, it is not as good when considering rare data. With a DHT, as long as there is at least one node hosting the data, it will be found eventually. With DTS, there is no guarantee that a piece of data will be found.\nThere are multiple potential solutions in order of feasibility:\n Use a DHT in addition to DTS by default Figure out how to get DTS to support rare files natively, perhaps by making nodes send out traversal packets pointing to themselves along the network to create artificial paths. Store routing coordinates / routing areas on the Reverse Hash Lookup. Implement a Network Coordination feature that tells all nodes in the network to notify a node when they find the requested data. (induces denial of service vector, probably a bad idea)  "},{"id":49,"href":"/docs/spec/dither/routing/distance-based-routing/","title":"Distance Based Routing","section":"Docs","content":"Distance Based Routing #  The goal of Distance Based Routing (DBR) is to obfuscate connections between computers on the Dither network. It works similarly to I2P \u0026amp; TOR, but is vastly improved by taking into account where proxy nodes are, instead of randomly selecting proxy nodes. It also allows for you to choose the trade-off between anonymity and speed.\nStructure #  There are many parts of Distance-Based Routing.\n  Network Organization  Locating Local Peers Calculating Routing Coordinates   Bandwidth Trading Configurable Routing  Network Traversal Network Searching Onion Routing Routing Wormholes    Network Organization #  The idea behind network organization is to be able to create a network that reflects the real-world positions of the computers. This is so that it is easy to calculate the latency between different locations in the network and to optimise routing paths.\nNote: You can also read the network organization research paper (or don\u0026rsquo;t, its not that good)\nLocating Local Peers #  The general idea is that each node that wants to join the network will first connect to one or more bootstrapping nodes. The connecting node will then request from those nodes more nodes to connect to and test all those new nodes for the time it takes packets to travel back and forth from them (packet latency). The new known nodes will then be ordered by the lowest latency. Those new closest nodes will then be asked for their closest nodes and this will continue recursively until all the nodes closest to the connecting node are found.\nThe specific protocol is as follows: [WIP]\nCalculating Routing Coordinates #  Calculating Route Coordinates\nBandwidth Trading #  Configurable Routing #  "},{"id":50,"href":"/papers/","title":"Papers","section":"About","content":"Papers #   Distance Based Routing Whitepaper\n"},{"id":51,"href":"/inspiration/","title":"Inspiration","section":"About","content":"As fundamental freedoms are continually encroached upon, having a decentralized and democratic internet is more important than ever before. Unfortunately, the current state of progress for internet decentralization is a big fragmented mess of different projects trying to do different things, but not effectively enough. Not enough ideas are shared, not enough people are talking. The biggest usage of peer-to-peer tech is Bittorrent, which has been around for 2 decades. Other parts of internet decentralization have been mostly re-centralized by necessity for ease of use (such as LBRY or Ethereum). This fragmented ecosystem is in desperate need of one project that can replace all the necessary parts of the internet so that reliance on centralized services is not needed anymore.\nProjects that have inspired Dither #   Multiformats\n Multiformats aims to fix the problem of future-proofing systems into future ages of computing. Dither will use a few of the multiformats, such as multihash, to future-proof and to be compatible with IPFS.   Stellar Conensus Protocol\n Byzantine Federated Voting is a really fast and flexible system for consensus, it just has to be implemented well.   Monero\n Monero is the only cryptocurrency that actually has most of what a crypto currency hould have. Transactions are completely anonymous, transaction fees are very low and it's not managed by a single company. Dither will improve on this with its own suite of cryptocurrencies that are all completely anonymous and take advantage of better consensus protocols for functionally instant payment.   IPFS\n IPFS is a core project in the world of web3, and a really good start to the decentralized internet. However, it is simply too slow and hard to interface with. Dither\u0026rsquo;s Directional Trail Search will greatly improve on the speed and efficiency of fetching data, as well as supporting more ways of representing data and storing data more efficiently.  DNS - The Domain Name System is structurally decentralized, but it is centrally managed by ICANN, an organization with the authority to control domain name registration. Dither will have its own naming system that will replace DNS and allow for much better systems of naming things. This naming system will be built on the Reverse Hash Lookup system.\n TOR \u0026amp; I2P\n These \u0026ldquo;Hidden Networks\u0026rdquo; are very important for obfuscating connections between people on the internet. However, they are very slow due to their nature of randomly routing connections through different nodes. Dither will improve on this with Distance-Based Routing, a routing protocol that takes latency and throughput into account when routing packets, allowing for the user to choose between better privacy or faster connection. Dither may also implement a anonymous routing technology called HORNET to allow for additional efficiency when establishing obfuscated connections.  Other projects that are inspiring dither are: Nomia, IPLD, IOTA, Solidity, Unison, zk-STARKS, and more.\n"}]