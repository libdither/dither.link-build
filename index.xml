<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>About on Dither Link</title>
    <link>https://www.dither.link/</link>
    <description>Recent content in About on Dither Link</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://www.dither.link/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/</guid>
      <description>Dither Application Index #  List of application Ideas #    Dither Chat - Community Chat application aiming to replace Discord. Provides e2ee encrypted DMs, voice chat, servers, voting, and integration with most other chat protocols.  Dithca - Comprehensive &amp;amp; Versatile decentralized comment system where anyone can comment on any type of data structure on Dither. Can interface with most other centralized comment systems and deal with misinformation &amp;amp; crediting using a comprehensive community flagging system.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/analytics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/analytics/</guid>
      <description>Anonymous Analytics #  Analytic collection is usually non-respecting of privacy, but it should be possible to create a system of analytics that reveals as little identifying information as possible using information theory and the decentralized nature of Dither.
Rough Idea #  Author specifies what kind of analytics they want and how specific they want. Analytics must be proportions or averages. Users manually (or automatically based on settings) pick which fields they want to divulge.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/compilation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/compilation/</guid>
      <description>Compilation #  Disp is very modular by design and the compilation system is no exception.
The general process goes like this:
 User edits file File is interpreted down to a collection of data structures containing the symbols, functions, and type definitions of that file as well as any external modules that are referenced User runs program Various macros run to generate lower-level parts of the program, eventually compiling down to pure lambda calculus and monadic Funclets&amp;quot; representing any side effects the program might have.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/de-brujin-index-alternative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/de-brujin-index-alternative/</guid>
      <description>Lambda Trees: A deduplication-friendly lambda-calculus construction #  The current most well known way of representing the lambda calculus is De Brujin Indicies.
This is where you have 3 variants of a lambda Term:
 Var(Number) - Number represents how many layers of abstraction (lambdas) the variable is away from its intended binding App(Term, ...) - Application is a list of Terms Lambda(Term) - Lambda represents an abstraction point  An example of what this might look like for common equations:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/disp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/disp/</guid>
      <description>Disp (Dither-Lisp) (WIP) #  Everything is data. Programs are interpreted data that manipulates other pieces of data.
Disp is a programming language that takes this concept to its logical conclusion with some functional programming and type theory sprinkled in where programs are composed functions and functions are data.
Goals #   Extremely fast compile times Extremely fast execution time Support for any possible cpu or interpreter Maximum re-use of code (data) Interface for defining hashtypes and hashtraits.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/examples/assembly/6502-assembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/examples/assembly/6502-assembly/</guid>
      <description>Disp compiling to 6402 Bytecode #  6402 assembly has a relatively small number of instructions so it is a good starting point when looking at how compiling works in Disp.
Instruction Abstraction #  To work in disp, first every 6502 instruction must be abstracted out to either a pure function or a monadic function.
Pure functions are easy to derive. Take for example the INX (Increment X) instruction for the 6502.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/examples/assembly/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/examples/assembly/hello-world/</guid>
      <description>Assembly Layer #  Disp compiles directly from high-level to cpu machine code. This means that it is possible to write low-level assembly commands directly within high-level code (although this is a bad idea)
x86-64 #  This is a simple Hello World program for linux written in x86 assembly compiled with nasm.
global _start section .data msg: db &amp;#34;Hello, world!&amp;#34;, 10 msglen: equ $ - msg section .text _start: mov rax, 1 ; write(  mov rdi, 1 ; STDOUT_FILENO,  mov rsi, msg ; &amp;#34;Hello, world!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/funclets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/funclets/</guid>
      <description>Funclets #  Funclets are types in disp that together form a functional abstraction over the stateful nature of CPU instructions. They are the basic building blocks of every Function in disp and can be easily combined, customized, and compiled to specific target platforms.
Each funclet is a unique identifier that links to code that can turn it into cpu-specific procedures via reverse hash lookup.
An example #  One example of a funclet would be the add operation.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/functions/</guid>
      <description>Functions #  The end goal of a compilation process is to generate data that can be interpreted by a cpu or an interpreter. This is typically called &amp;ldquo;bytecode&amp;rdquo; or &amp;ldquo;intermediate language&amp;rdquo;.
Everything in disp is represented by lambda calculus. The compilation process is simply figuring out how to map lambda function hashes to pieces of output data.
Say there is a lambda expression that when applied to two 8-long pair of type either true or false, it reduces to a single 8-long pair.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/live-rollbacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/live-rollbacks/</guid>
      <description>Live Rollbacks #  While disp is a compiled language, it is also a purely functional language which means that changes to state can be saved in an efficient manner and rolled back when necessary.
This means that a user can change the code of the program and while the program is running, updates parts of the running process&amp;rsquo;s code and roll back the program to the state before the process ran the code.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/syntax/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/syntax/</guid>
      <description>Syntax #  Disp&amp;rsquo;s default syntax is similar to lisp with some Rust naming conventions sprinkled in. However, since disp files are stored as binary objects, disp code can be displayed in any way preferred by the programmer (javascript-like rust-like go-like etc.)
Examples #  // This is a comment, it also doubles as documentation // Variables (set ten 10:b64) // variable names can have most symbols in them (set ten?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/disp/types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/disp/types/</guid>
      <description>Types #  There are various core types in Disp here are some main ones pertaining to compilation.
The Funclet type facilitates the compilation from functional human-reasonable code to procedural machine-interpreted code without compromising performance.
Funclet is generic over an instance of CompilationTarget. type Funclet&amp;lt;Target: CompilationTarget&amp;gt;
 input: Target::StateLocation  CompilationTarget describes all the necessary details to convert a chain of Funclets to a list of Operations trait CompilationTarget
 type StateLocation - a type definition for a location in a global state used by Funclets.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dithca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dithca/</guid>
      <description>Dithca #  A comprehensive commenting system built on top of Dither #  Decentralized comment system adaptor. Fully customizable comment system stored as a Dither Consensus Chain that can be created from any piece of data. Uses Reddit&amp;rsquo;s upvote/downvote system by default Acts on its own or as a proxy overlay to various comment sites.
Comment Chain #  WIP: Figure out how dither consensus works
Comment Sort methods #  https://medium.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dither-chat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dither-chat/</guid>
      <description>Dither Chat #    Dither Chat   What is it  Users &amp;amp; Sync  Chat Events  Event Storage - Storage of a sequence of events in memory or storage  Trusted Friends Application API  Chat Interface  Direct Messaging  Group messaging  Servers   Roles, Tags &amp;amp; Colors      What is it #  Dither Chat is a decentralized communication application using the Dither protocol.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dither-coin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dither-coin/</guid>
      <description>Dither Coin (Ideas are Work-In-Progress) #  Dither&amp;rsquo;s built-in cryptocurrency aims to solve all existing problems with crypto:
 Scalability  Uses IOTA block structure combined with Federated Byzantine Voting for coordination. Most users won&amp;rsquo;t store the entire network history, just a slice of the current state relevent to performing transactions.   Speed  Using Stellar Consensus Protocol and IOTA will be helpful to speed. Bad Idea?: Also, there will be establishment of Zones in the network that have their own sub-exchanging separate from the rest of the network for fast local transactions.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dither-dex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dither-dex/</guid>
      <description>Dither Decentralized Exchange #  An exchange is a place that facilitates the exchange of goods (usually intangible ones). The Dither Exchange will be primarily geared towards the exchange of intangible goods, but it will support selling physical goods as well.
The core mechanism of the exchange is publically listing sell and buy orders and making them easily acessible to peers that satisfy certain constraints. (Perhaps they must prove that they are within a certain distance to the seller or that they have a certain amount of specific karma).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dither-git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dither-git/</guid>
      <description>Dither-git #  Extension for Git allowing for interaction with git repositories hosted on Dither.
Ideas #   Pull requests and issues can be opened on any file or directory. Since everything is a content-addressed DAG, git repositories can contain other git repositories and share data with other git repositories naturally.  People will be able to see using reverse-hash-lookup newer versions of shared files and be able to update them in their own repository.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dither-versioning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dither-versioning/</guid>
      <description>Dither Versioning (dv) #  This is a versioning system for versioning any kind of tree structure. It is meant to function as a replacement for git.
General Structure #  ObjectDelta: - Generates an Object with a change
 object: Link&amp;lt;Object&amp;gt;(link_type: Relevent) base_object: Link&amp;lt;Object, Linked&amp;gt;  Object: - Compressed Object, Binary or Text
 base_object: Option&amp;lt;ObjectDelta&amp;gt; compresed data: List&amp;lt;Byte&amp;gt;  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/dithix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/dithix/</guid>
      <description>Dithix #  Solves the packaging problem
Takes ideas from: Nix
Features of a good package manager:
 Download packages Run packages Update packages Hack on packages Deploy packages Reproducibly configure packages across many different systems Package storage &amp;amp; versioning + deduplication  Package trait is valid if the output is built from the derivation
Downloading Packages #  This is handled by Dither. Package name is mapped to a release hash tree w/summary and the desired version is selected.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/nomia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/nomia/</guid>
      <description>Nomia is a program that allows for the standardization of composing data. Names, Resources &amp;amp; Systems in Nomia will be able to be represented and stored in Dither.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/predictive-keyboard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/predictive-keyboard/</guid>
      <description>Predictive Keyboard #  Inspired by the way China does predictive typing ( Johnny Harris). And how various keyboards on mobile platforms aggregate the usage data of many people</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/protocol-of-truth/examples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/protocol-of-truth/examples/</guid>
      <description>Potential Examples for the Protocol of Truth #  To flesh out the idea and provide context of what this might look like, here are some real-world examples of videos that would be labeled under the protocol of truth.
Example 1: Simple Factual Error #  In Youtuber Fireship&amp;rsquo;s video &amp;ldquo;Rust in 100 Seconds&amp;rdquo; at 0:55 he incorrectly says that mutable values are stored in the heap.
Ideal processes of correction:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/protocol-of-truth/protocol-of-truth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/protocol-of-truth/protocol-of-truth/</guid>
      <description>Protocol of Truth #  This is a protocol of back and forth debate with the aim to evaluate the quality and truthfulness of content posted to the internet.
If you have ever seen a photoshopped post on social media, or a video citing a badly done study, this techno-social protocol aims to inform through discourse the truthfulness of a given piece of media to anyone who might come across it.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/protocol-of-truth/protocol-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/protocol-of-truth/protocol-types/</guid>
      <description>Types of Labels for the Protocol of Truth #  The protocol of truth is a protocol for applying labels to pieces of content. There are a lot of things a piece of content can be generally and specifically.
There are various labels for content. These labels are called Types. They are typically split up into categories of Truths and Falses.
Truths #  What is Truth? What Makes something True?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/tree-of-math/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/tree-of-math/</guid>
      <description>Tree of Math #  Defining all of math programatically using set theory.
Traits #  Defining the fundamental structures of math:
 Variable  Math Def: An variable in an axiomatic system Struct Def: Uniquely identify a variable in a system Struct: { id: Varint }   Proposition  Math Def: A true or false statement based on a system of propositions Structure Def: A boolean value corresponding to a predicate statement on a proposition system.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/applications/user-proofs/verified-human/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/applications/user-proofs/verified-human/</guid>
      <description>Verified Human Proof #  The Verified Human Proof is a built-in anti-spam and anti-bot system that works across Dither. It is a zero-knowledge proof for prooving one-sidedly that an account is indeed used by a human.
There are two types of verified human proofs: marked human, trusted human, unique human.
 A marked human signifies an account with human-like tendencies. A trusted human is an account that has a unique human fingerprint that can be traced across accounts.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/copyright-is-cancer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/copyright-is-cancer/</guid>
      <description>Why Copyright is Cancer #  Copyright is ineffective in the internet age. Any piece of content can be pirated on a massive scale without the original creator even knowing. The only thing copyright does is suppress derivative creation on forums with strict copyright adherence. See these videos on why the current copyright system is broken and why it makes no sense. This document outlines an alternate system of funding creation that Dither aims to create.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/</guid>
      <description>The Dither Project #    The Dither Project  What is it?   No, but really, What is it?  What&amp;rsquo;s this about replacing the Internet?  Potential Applications:    Core Tenets  Structure   Finding Data Links (Reverse Hash Lookup)  Dither Chain References  Dither Consensus Chains  WIP - Dither Weighted Voting  Inspiration    What is it? #  Dither is a project that aims to decentralize the internet!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/application-design-philosophy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/application-design-philosophy/</guid>
      <description>Application Design Philosophy #  Application APIs should be future-proofed as much as possible
Application GUIs should be generally be as cross platform as possible.
There should be different modes of use for different user skill levels to try and accomidate as many people as possible.
 These modes should enable/disable various aspects of configurability in the application Simple mode should be super easy to use for anyone and come with a quick tutorial  Configuration options should be assumed as much as possible,   Default mode should come with a tutorial and explain how modes work and how to change them Advanced mode assumes the user already knows how to use the app or can figure it out on their own.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/consensus/byzantine-federated-voting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/consensus/byzantine-federated-voting/</guid>
      <description>Byzantine Federated Voting #  TLDR: https://www.scs.stanford.edu/~dm/blog/simplified-scp.html
This will be used as an optional alternative to</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/consensus/consensus-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/consensus/consensus-algorithms/</guid>
      <description>Consensus Ideas #  List of various consensus algorithms&#39; pros &amp;amp; cons that could be utilized by Dither for different applications
 Proof of Work  Cons  Very inefficient &amp;amp; slow (transactions take multiple minutes or more to verify) Uses a lot of energy Causes avenue of abuse for malware crypto miners Requires sufficient size of network to be trusted Large storage requirements for full node Miners congregate into centralized pools Slowness pushes to centralization   Pros  Simple to understand, easy to implement Easy     Proof of Stake  Cons  Only works for cryptocurrencies (need staking incentive) Faster than proof of work Large storage requirements for full node   Pros  Faster and more energy efficient than proof of stake     Proof of Weight  General term to describe systems that work similarly to Proof of Stake, where there is some shared value that determines how   Stellar Consensus Protocol (Byzantine Federated Voting)  Cons  Large storage requirements for full node Uncertain consensus (health of network slices can&amp;rsquo;t be judged) Tendency towards centralization Lots of packets   Pros  ~5 seconds / transaction, extremely low transaction fees Can be integrated with social media to reflect IRL social connections as quorum slices.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/consensus/distance-aware-consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/consensus/distance-aware-consensus/</guid>
      <description>Area-Aware Consensus #  Why Area-Aware? Information takes time to travel and sometimes consensus only needs to be done in a local manner. With plans for colonies on other planets within decades, consensus algorithms that are aware of the time it takes for information to travel and don&amp;rsquo;t require the consensus of all the computers in the network will be invaluable.
Ideas #  Tiered Consensus #  Create tiered layers of consensus at different scales that cover different numbers of people, each high layer covering more people and being slower than the last.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/consensus/eventual-consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/consensus/eventual-consensus/</guid>
      <description>Eventual Consensus #  What? #  Eventual Consensus is not quite what it sounds like. It is consensus in a network that is lazy. This is useful for public information spreading where not everyone has to have the information in a timely fasion.
Why? #  For consensus applications that don&amp;rsquo;t have a timeline (blockchains and directed acyclic graphs) this method of consensus is useful because it lets nodes kinda do their own thing if they aren&amp;rsquo;t interested in what is being spread around the network in a given moment.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/consensus/modular-consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/consensus/modular-consensus/</guid>
      <description>Modular Consensus (WIP) #  What is it #  Modular Consensus is a tool that creates a framework for creating any configuration of common consensus algorithms for specific applications.
What does it do? #  Modular Consensus allows you to create custom consensus configurations using linked blockchain or directed acyclic graphs with most(?) kinds of proof algorithm (Proof of Work, Proof of Stake, Etc.).
How does it specifically work? #  Modular consensus uses a specific hashtype to define the main characteritics and configuration of a consensus algorithm (onboarding method, consensus algorithm, data to be agreed upon).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/core-traits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/core-traits/</guid>
      <description>Core Traits #  This document contains a list of Core Traits for the self-defining structures system.
Multihash: Hash of some data.
 Sized: Dynamically sized Valid: Valid if follows the multihash format.  Trait: Structure of a Trait definition
 Sized: Dynamically Sized  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/hashtypes-old-old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/hashtypes-old-old/</guid>
      <description>Self-Defining Structures #  (A.k.a. Hashtypes)
Self defining structures are pieces of data that link to their own format, telling the program how they are structured and how to validate them.
The workings of this system are heavily dependent on Directional Trail Search and Reverse Hash Lookup.
Ideas To Add to this Doc #   Make structures&#39; fields binary-ordered by default to increase the chances that developers will use and create the same structures.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/hashtypes-old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/hashtypes-old/</guid>
      <description>Idea Document for Hashtypes #  What is a Hashtype #  Generally, A hashtype is a piece of data, prepended by a Multihash. The multihash can be resolved using directional-trail-search to some data that defines the layout of the hashtype.
A type definition (seen below) contains a type name, multiple fields, and a type for each field. The most primitive type definition (Layout) allows for the creation of dependent types.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/hashtypes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/hashtypes/</guid>
      <description>Hashtypes #  Hash types are how Dither deals with data.
A fundamental property of hash types are that they describe their own domain. This includes: what data types make up the domain (i.e. bytes, types, other data types) and how those datatypes may be restricted (i.e. a data type might be variable in length depending on another type like a list).
Fundamental Types #  There are a few fundamental types.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/lambda-calculus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/lambda-calculus/</guid>
      <description>Lambda Calculus #  Idea - Lambda calculus to represent types
Representation #  Representation of Lambda expressions in Hashtypes
Lambda Tree representation #  There are 4 parts to this hashtype representation.
 Variable - Multihash cast to 0  Represents a variable (unknown whether it is bound or unbound)   Lambda - Multihash cast to 1  &amp;lt;VarUInt&amp;gt;&amp;lt;Bits&amp;gt;&amp;lt;Multihash&amp;gt;  &amp;lt;VarUInt&amp;gt;&amp;lt;Bits&amp;gt; represents a list of variable-length bit-arrays, each bit of the array represents which a direction (left or right) which should be traversed down when encountering an Application expression     Application - Multihash cast to 2  &amp;lt;Multihash&amp;gt;&amp;lt;Multihash&amp;gt;   Select - Multihash cast to 3  &amp;lt;Multihash&amp;gt;&amp;lt;Multihash&amp;gt; Represents waiting on 2 operations and returning them in order of completion.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/primitive-traits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/primitive-traits/</guid>
      <description>Common Primitives for Self-Defining Structures #  These primitive types are defined by the implementation of Dither. They can be identified through hashes that count up from 0.
For more detailed explanations see the hashtypes document
VarUInt - Dynamically sized unsigned integer
Layout - Layout for defining structures
Unknown - Dynamically sized unknown data (defined by wrapper types with Traits)
Trait - Reverse-Linked trait that defines inputs and outputs for a program implementation</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/hashtypes/self-verifying-structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/hashtypes/self-verifying-structures/</guid>
      <description>Self-Verifying Structures #  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/proof-of-linked-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/proof-of-linked-data/</guid>
      <description>Proof of Linked Data #  The idea behind proof of linked data is that if you have the hash of a hashtype. You can prove things about that hashtype.
The behind proof of linked data is asking the question: &amp;ldquo;prove that when function x is applied to the data that generates hash y, results in z&amp;rdquo;.
Potential applications of this simple concept are endless:
 put burden of proof on the creater of the object.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/reverse-hash-lookup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/reverse-hash-lookup/</guid>
      <description>Reverse Hash Lookup (WIP) #  Allows for finding what structures link to a given structure.
Example: Someone can find a comment that links to a post, just given the hash of the post.
IDEAS TO ADD #  Keep track of the number of child nodes for each node in the tree so you can merge reverse hash lookup trees easily in a peer-to-peer fashion which means consensus can be less rigourous.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/user-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/user-management/</guid>
      <description>Dither&amp;rsquo;s User API #  Purpose #  Dither is aiming to replace the internet, so it needs a standard method of accounting. This includes storing user data publicly and privately, identifying users, and authenticating users. These accounts need to be able work across devices and should have varying levels of authentication for varying levels of storage of information. Dither accounts should also be able to prove qualities about themselves to external parties using zero-knowledge proofs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/data/zero-knowledge-proofs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/data/zero-knowledge-proofs/</guid>
      <description>Zero Knowledge Proofs #  These are really cool btw.
Potential Applications:
 Anonymous Transactions Proof of Karma (proove that someone is trustworthy enough on the Dither network for them to be trusted without giving away more information than necessary) KYC/18+ requirements - For abiding by laws. (Is this even possible?) - Proove that some well-defined operation was done correctly on a given piece of data, i.e. that a binary was compiled correctly with no tampering.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/encryption/decentralized-kerberos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/encryption/decentralized-kerberos/</guid>
      <description>Decentralized Kerberos #  Inspired by Kerberos authentication, by which every peer has a semi-permanent symmetric key (password) with a central server which then calculates one-time keys to establish encrypted connections to specific requested devices on a network.
Awesome Computerphile video: https://www.youtube.com/watch?v=qW361k3-BtU
Idea #  Decentralized kerberos removes the idea of a centralized server and instead establishes a direct symmetric connection to the desired peer by finding various peers near it an asking them for all act as a key authentication intermediary.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/encryption/multikey/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/encryption/multikey/</guid>
      <description>Multikey #  (WIP)
Data structure for representing encryption keys of any type and providing the algorithms to encrypt arbitrary data.
Multikey
 key_type: VarUInt length: VarUInt data: Unknown $Size = [default implementation]   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/routing/directional-trail-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/routing/directional-trail-search/</guid>
      <description>Directional Trail Search #  Allows for a computer to fetch a piece of data from another computer based on the multihash of that piece of data, as long as at least one computer has the data.
General Structure #  Directional Trail Search takes inspiration for how ants find food: scent and pheromone trails. In Dither, these take form as &amp;ldquo;holes&amp;rdquo; and &amp;ldquo;trails&amp;rdquo;. Holes form when nodes broadcast to nearby nodes (nearby in terms of routing coordinates) that they have the data behind a given hash.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/docs/spec/dither/routing/distance-based-routing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/docs/spec/dither/routing/distance-based-routing/</guid>
      <description>Distance Based Routing #  The goal of Distance Based Routing (DBR) is to obfuscate connections between computers on the Dither network. It works similarly to I2P &amp;amp; TOR, but is vastly improved by taking into account where proxy nodes are, instead of randomly selecting proxy nodes. It also allows for you to choose the trade-off between anonymity and speed.
Structure #  There are many parts of Distance-Based Routing.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.dither.link/papers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/papers/</guid>
      <description>Papers #   Distance Based Routing Whitepaper</description>
    </item>
    
    <item>
      <title>Inspiration</title>
      <link>https://www.dither.link/inspiration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.dither.link/inspiration/</guid>
      <description>As fundamental freedoms are continually encroached upon, having a decentralized and democratic internet is more important than ever before. Unfortunately, the current state of progress for internet decentralization is a big fragmented mess of different projects trying to do different things, but not effectively enough. Not enough ideas are shared, not enough people are talking. The biggest usage of peer-to-peer tech is Bittorrent, which has been around for 2 decades. Other parts of internet decentralization have been mostly re-centralized by necessity for ease of use (such as LBRY or Ethereum).</description>
    </item>
    
  </channel>
</rss>
