<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dither Ideas</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="dither.html"><strong aria-hidden="true">1.</strong> Dither</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dither/structure.html"><strong aria-hidden="true">1.1.</strong> Structure</a></li><li class="chapter-item expanded "><a href="dither/routing/distance-based-routing.html"><strong aria-hidden="true">1.2.</strong> Distance-Based Routing</a></li><li class="chapter-item expanded "><a href="dither/routing/directional-trail-search.html"><strong aria-hidden="true">1.3.</strong> Directional Trail Search</a></li><li class="chapter-item expanded "><a href="dither/data/reverse-hash-lookup.html"><strong aria-hidden="true">1.4.</strong> Reverse Hash Lookup</a></li><li class="chapter-item expanded "><a href="dither/data/zero-knowledge-proofs.html"><strong aria-hidden="true">1.5.</strong> Zero Knowledge Proofs</a></li><li class="chapter-item expanded "><a href="dither/data/user-management.html"><strong aria-hidden="true">1.6.</strong> User Management</a></li><li class="chapter-item expanded "><a href="dither.html"><strong aria-hidden="true">1.7.</strong> Consensus</a></li></ol></li><li class="chapter-item expanded "><a href="disp/disp.html"><strong aria-hidden="true">2.</strong> Disp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/universal-system-of-types.html"><strong aria-hidden="true">2.1.</strong> Universal System of Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/type-system.html"><strong aria-hidden="true">2.1.1.</strong> Standard Type System</a></li></ol></li><li class="chapter-item expanded "><a href="disp/syntax-agnosticism.html"><strong aria-hidden="true">2.2.</strong> Syntax Agnosticism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/syntax.html"><strong aria-hidden="true">2.2.1.</strong> Standard Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="disp/names.html"><strong aria-hidden="true">2.3.</strong> Naming with Knowledge Graphs</a></li><li class="chapter-item expanded "><a href="disp/modular-parsing.html"><strong aria-hidden="true">2.4.</strong> Modular Parsing</a></li><li class="chapter-item expanded "><a href="disp/hardware-modeling.html"><strong aria-hidden="true">2.5.</strong> Hardware Modeling</a></li><li class="chapter-item expanded "><a href="disp/hashtypes/hashtypes.html"><strong aria-hidden="true">2.6.</strong> Hashtypes</a></li><li class="chapter-item expanded "><a href="disp/implementation.html"><strong aria-hidden="true">2.7.</strong> Implementation Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/bind-trees.html"><strong aria-hidden="true">2.7.1.</strong> Bind Trees</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="applications.html"><strong aria-hidden="true">3.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applications/application-design-philosophy.html"><strong aria-hidden="true">3.1.</strong> Design Philosophy</a></li><li class="chapter-item expanded "><a href="applications/dither-chat.html"><strong aria-hidden="true">3.2.</strong> Chat Client - Dither Chat</a></li><li class="chapter-item expanded "><a href="applications/dithca.html"><strong aria-hidden="true">3.3.</strong> Comment System - Dithca</a></li><li class="chapter-item expanded "><a href="applications/dithca.html"><strong aria-hidden="true">3.4.</strong> Package Manager - Dithix</a></li><li class="chapter-item expanded "><a href="applications/protocol-of-truth/protocol-of-truth.html"><strong aria-hidden="true">3.5.</strong> Protocol of Truth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applications/protocol-of-truth/examples.html"><strong aria-hidden="true">3.5.1.</strong> Usage Examples (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="applications/dither-coin.html"><strong aria-hidden="true">3.6.</strong> Not your typical Cryptocurrency - Dither Coin</a></li><li class="chapter-item expanded "><a href="applications/d-framework/d-framework.html"><strong aria-hidden="true">3.7.</strong> Browser Alternative - D Framework</a></li></ol></li><li class="chapter-item expanded "><a href="future-vision.html"><strong aria-hidden="true">4.</strong> Future Vision of Dither</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Articles</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="copyright-is-cancer.html"><strong aria-hidden="true">5.1.</strong> Copyright is Cancer</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Dither Ideas</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-dither-project"><a class="header" href="#the-dither-project">The Dither Project</a></h1>
<ul>
<li><a href="dither.html#the-dither-project">The Dither Project</a>
<ul>
<li><a href="dither.html#what-is-it">What is it?</a></li>
<li><a href="dither.html#a-plan-for-the-future-of-the-internet">A Plan for the Future of the Internet</a></li>
</ul>
</li>
<li><a href="dither.html#core-tenets">Core Tenets</a></li>
<li><a href="dither.html#structure">Structure</a>
<ul>
<li><a href="dither.html#core-process">Core Process</a></li>
<li><a href="dither.html#service-swarm">Service Swarm</a></li>
<li><a href="dither.html#user-interface">User Interface</a></li>
<li><a href="dither.html#interface-layer">Interface Layer</a></li>
</ul>
</li>
<li><a href="dither.html#other-links">Other Links</a>
<ul>
<li><a href="dither.html#inspirations-for-dither">Inspirations for Dither</a></li>
</ul>
</li>
</ul>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>Dither is a project with the goal of decentralizing the internet. It is a toolbox of various tools application developers can use to communicate privately, host data, manage accounts much more. It is currently being developed by <a href="https://github.com/zyansheep">@Zyansheep</a> and temporarily hosted via GitHub under the <a href="https://github.com/libdither">libdither</a> organization.</p>
<h2 id="a-plan-for-the-future-of-the-internet"><a class="header" href="#a-plan-for-the-future-of-the-internet">A Plan for the Future of the Internet</a></h2>
<p>The plan behind Dither is to create an modern internet unencumbered by any kind of central control. To accomplish this, Dither must somehow replace existing apps and services <em>by outcompeting them</em>. This is an incredibly monumental task, but there are some things that may help in Dither's favor.</p>
<ul>
<li><strong>No Hosting Costs</strong> — Being decentralized means the users host everything. If we can create a system to make it as painless as possible to host data, that would be ideal.</li>
<li><strong>Redesigning Everything is Sometimes Good</strong> — If applications using Dither are fundamentally better designed than the alternative and it is easy to switch, users will be more likely to use them.</li>
<li><strong>No Intellectual Property</strong> — Intellectual property protections do not apply to the core of Dither since it is a peer-to-peer network. This means that new platforms can be immediately populated with any existing content people might want to watch. Note: Precautions should be taken to make sure creators have a say in if they want their content to be shown on mainstream applications using the protocol to prevent public backlash.</li>
<li><strong>Standardization</strong> — Dither's ecosystem of APIs will all be compatible with each other which will infinitely improve the experience of the user. (Imagine being able to use a Discord-like chat room or a Reddit-like comment system underneath a YouTube video, or really any kind of system you want. It's all modular!).</li>
<li><strong>Natural Incentives</strong> — Similar to Brave browser's tipping system, If applications built on Dither have good incentive systems for content creation that extends to existing content, then creators whose content is uploaded to the network will automatically accrue income that will then be an incentive for them to claim their money and create an account. Unlike Brave, there won't be any KYC requirements :).</li>
</ul>
<p><em>The aim for Dither is to replace existing centralized applications with decentralized alternatives that are unified through their use of a singular, modular protocol.</em></p>
<p>See the <a href="applications.html">application document</a> for outlines of various applications that could be built using Dither.</p>
<h1 id="core-tenets"><a class="header" href="#core-tenets">Core Tenets</a></h1>
<p>It seems necessary for projects to have guidelines so that everyone may be on the same page. These are the ones I've chosen for now, as with everything, they are subject to change.</p>
<p><strong>Dither should be as modular as possible.</strong></p>
<ul>
<li>Reasoning: There should be no part of Dither that is difficult to replace with a different implementation and people should be able to pick and choose which parts they want.</li>
</ul>
<p><strong>Dither protocols, formats, and communities should be as interoperable as possible with existing protocols, formats, and communities</strong></p>
<ul>
<li>Reasoning: To grow Dither's userbase, It should be as easy as possible to transition to Dither from other services.</li>
<li>One example of this would be allowing someone to pull comments from Reddit / Youtube into <a href="applications/dithca.html">Dithca</a> and hosting them in a decentralized manner.</li>
<li>Another example might be <a href="applications/dithca.html">Dithca</a> storing Reddit credentials and being able to optionally interact with comment threads pulled from centralized websites.</li>
</ul>
<p><strong>Dither should rely on itself as much as possible for every aspect of development and usage.</strong></p>
<ul>
<li>Reasoning: It feels natural for a program to use itself if possible. Rust is written in itself, GitLabs is hosted using GitLabs, etc.</li>
<li>Code Versioning, Storage, Building, Distribution, and Social communication should all run through Dither applications if it won't compromise development too much.</li>
</ul>
<h1 id="structure"><a class="header" href="#structure">Structure</a></h1>
<p>Following the first tenet of Dither, in the future the lines between these layers will blur and everything will be a module. However, the design of current operating systems don't easily allow for shared code and data, requiring a more formal structure. In the future this layered structure will be replaced with a more <a href="dither/structure.html">flexible system</a>.</p>
<h2 id="core-process"><a class="header" href="#core-process">Core Process</a></h2>
<p>The Core Dither Process is the part that deals with all operating system-facing operations such as data storage, establishing peer-to-peer connections with other computers, in addition to managing all Dither services and connections between them.</p>
<p>This &quot;Core Process&quot; provides a few core APIs that only certain services running in the &quot;Service Swarm&quot; are allowed to use for security purposes. The idea behind a &quot;Core Process&quot; is to create a sandboxed environment for services to run in a safe manner.</p>
<p>peer-to-peer connections with other computers running Dither.
Currenly in the dither-sim program, this is implemented via a simple TCP stream. In the future this layer will be implemented using existing libraries such as <a href="https://libp2p.io/implementations/#transports">libp2p transports</a>, <a href="https://www.pluggabletransports.info/transports/">Pluggable Transports</a>, something else, or some amalgamation of all three. The idea behind this layer is to provide as many methods of communication as feasibly possible.</p>
<h2 id="service-swarm"><a class="header" href="#service-swarm">Service Swarm</a></h2>
<p>The service layer provides all functionality related to <a href="dither/routing/distance-based-routing.html">routing</a>, encryption, <a href="dither/routing/directional-trail-search.html">data storage</a>, <a href="dither/data/user-management.html">user management</a> and everything else. Each of these services are split up into separate modules each of which runs its own processes and communicates with other services through inter-process communication. </p>
<p>All these processes are managed as child processes under one &quot;main process&quot;. The main process contains the Transport Layer implementation, the routing protocol API and APIs for managing the child services as well as managing inter-process communication between child processes.</p>
<h2 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h2>
<p>The application layer contains services just like the service layer that are registered under the main process. These registered service's APIs can be used by other applications. </p>
<p>The application layer also refers to the application's core API, which is used by the interface layer. This &quot;core application API&quot; can be built into the applicaiton's executable, or it can run as a service under the main process and used by multiple interfaces. This is left up to the application developers. Applications with multiple interfaces should prefer to register application APIs under the main process.</p>
<p>Existing planned applications may be found <a href="applications.html">here</a>.</p>
<h2 id="interface-layer"><a class="header" href="#interface-layer">Interface Layer</a></h2>
<p>The final layer is the interface layer. This just refers to standalone applications that provide some kind of interface to the user using the services running under Dither.</p>
<p>These interfaces can be implemented however, but it is recommended for them to follow Dither's <a href="dither/application-design-philosophy.html">application design philosophy</a> for some level of standardization.</p>
<h1 id="other-links"><a class="header" href="#other-links">Other Links</a></h1>
<h3 id="a-hrefditherinspirationshtmlinspirations-for-dithera"><a class="header" href="#a-hrefditherinspirationshtmlinspirations-for-dithera"><a href="dither/inspirations.html">Inspirations for Dither</a></a></h3>
<p>Dither as with any creative endeavor takes inspiration from many other projects. This is a list of what parts of Dither have been inspired from other projects.</p>
<h1 id="structure-1"><a class="header" href="#structure-1">Structure</a></h1>
<p>This document outlines the major structure of Dither.</p>
<h2 id="system-manager"><a class="header" href="#system-manager">System Manager</a></h2>
<p>At the core of Dither is the system manager. This will be written in Rust and should only be run once on any given user account. The system manager provides a sandbox for Dither protocols and is built in a modular fashion to support any kind of setup or platform Dither might run on.</p>
<h3 id="core-services"><a class="header" href="#core-services">Core Services</a></h3>
<p>In order to sandbox Dither services, the system manager provides certain core services such as access to storage, network, or other Dither services.</p>
<ul>
<li>Service Manager
<ul>
<li>Provides any service with access the ability to organize other service's permissions, manage storage, as well as stop and start services at will.</li>
</ul>
</li>
<li>Network Service
<ul>
<li>Provides any service with access the ability to establish arbitrary TCP or UDP connections.</li>
</ul>
</li>
<li>Storage Service
<ul>
<li>Provides any service with access the ability to fetch and store data unique to that service.</li>
</ul>
</li>
</ul>
<p>Other services may be added as needed.</p>
<h3 id="service-swarm-1"><a class="header" href="#service-swarm-1">Service Swarm</a></h3>
<p>The system manager acts as a kind of sandbox for all services running on Dither and facilitates communication between different services.</p>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<p>This is a list of planned Dither services and their dependencies, note these may be split up into smaller sub-services.</p>
<ul>
<li>Distance-Based Routing, DBR (Network, Storage)</li>
<li>Directional-Trail Search, DTS (Distance-Based Routing, Storage)</li>
<li>Reverse-hash-lookup, RHL (Directional-Trail Search)</li>
<li>User Manager (DBR, DTS, RHL, Storage)</li>
<li>Dither Chat (DBR, DTS, RHL, User Manager, Storage)</li>
<li>Dithca (DTS, RHL, User Manager, Storage)</li>
<li>Protocol of Truth (DTS, RHL)</li>
</ul>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>Applications in Dither will be external programs that communicate with specific services in the Dither System Manager. 
i.e. 
Dither Chat will use the Dither Chat Service
Dithca will use the Dithca service.</p>
<p>Or applications can use a multitude of different services as needed.</p>
<h1 id="distance-based-routing"><a class="header" href="#distance-based-routing">Distance Based Routing</a></h1>
<p>Distance Based Routing (DBR) is a protocol to obfuscate connections between computers on the Dither network. It improves on speed and flexibility over existing solutions (i.e. I2P and TOR) by taking into account the latency between nodes on the network. Instead of having to randomly choose nodes from a list to route through, by knowing the relative latencies of nodes, routing paths between nodes can be chosen to optimize for low-latency or anonymity, or a balance of both.</p>
<p>Note: There is a <a href="https://www.dither.link/papers/distance-based-routing-whitepaper.pdf">research paper</a> comparing DBR to existing random-route solutions, for a somewhat amateurish comparison.</p>
<h2 id="the-main-idea"><a class="header" href="#the-main-idea">The Main Idea</a></h2>
<p>To figure out the relative latencies between nodes so as to establish low-latency paths to a destination, DBR makes the observation that the <strong>latency between nodes roughly correlates with the physical distance between them</strong>. This means coordinates can be assigned to nodes such that the communication latency between nodes can be estimated as the euclidian distance between coordinates. These coordinates will be referred to as &quot;routing coordinates&quot;.</p>
<p>While the goal of distancce-based routing could be achieved by assigning a routing coordinate to each node in the network, This has two major problems: </p>
<ol>
<li>
<p>Individual nodes or even whole parts of the network may be moving in relation to other parts of the network. (i.e. an airplane, or interplanetary communication). Thus requiring continuous recalculation of routing coordinates for all moving parties involved (which may include an entire planet, if used for inter-planetary routing).</p>
</li>
<li>
<p>Multiple networks may form independently and thus may have incompatible coordinate systems when communicating, requiring expansive re-syncronization or some kind of coordinate translation.</p>
</li>
</ol>
<p>The simple solution to this issue is to do what we humans do, <em>allow for different frames of reference</em>. Instead of each node calculating its own coordinates based on the coordinates of other nodes, each node is the center of its own universe and all other nodes are simply offset from itself. I will call these offsets &quot;relative routing coordinates&quot; (RRCs). When two nodes want to communicate with each other, they must figure out where they are relative to some shared frame of reference.</p>
<h2 id="peer-discovery"><a class="header" href="#peer-discovery">Peer Discovery</a></h2>
<p>To assign relative coordinates to nodes, there is a process of peer-discovery that functions as follows. This process happens whenever a new node joins the network.</p>
<ol>
<li>New node bootstraps onto the network by initiating connection to one or more existing nodes.</li>
<li>New node tests response times (latency) to connected nodes (peers). </li>
<li>New node requests from some subset of lowest-latency peers that it would like more peers.</li>
<li>New node's peers notify some slice of their peers that a new node would like more connections.</li>
<li>Notified nodes initiate connection with new node and new node measures latency to new peers.</li>
<li>New node takes note of the smallest latencies of its peers and goes back to step 3 until there are no closer nodes who want to peer.</li>
<li>After a certain number of closest nodes are found whose latency measurements are stable, the new node then calculates relative routing coordinates for all of its active peers via <a href="https://en.wikipedia.org/wiki/True-range_multilateration">multilateration</a> and broadcasts them to all the nodes used in the calculation.</li>
</ol>
<p>Through this process, a distributed small-world network is formed that reflects the physical topology of the relative orientations of the nodes.</p>
<h2 id="relative-routing-coordinates"><a class="header" href="#relative-routing-coordinates">Relative Routing Coordinates</a></h2>
<p>Relative Routing coordinates (RRC) in this system acts as a replacement for IP addresses in conventional routing.</p>
<h3 id="process"><a class="header" href="#process">Process</a></h3>
<p>A packet with an RRC can be routed to its destination via the following process:</p>
<ol>
<li>Node chooses the peer that will receive the packet next by comparing RRC directions</li>
<li>Node subtracts next peer's RRC from packet's RRC</li>
<li>Node forwards modified packet to next peer</li>
</ol>
<p>The process continues until the packet's RRC is all zeroes and the last node it reaches either is the destination node, knows the destination node, or is the wrong node in which case the packet is dropped or sent back depending on the packet type.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Compared to the global routing tables and complicated peering and address space allocation protocols that the existing internet uses. RRCs are much better for peer-to-peer applications because they are pretty much infinitely scalable. </p>
<p>That said, RRCs in some ways give away <em>more</em> information than traditional IP addresses do. Since the self-organized networks that use RRCs reflect real-world network topologies, just knowing someone's routing coordinate relative to you could be akin to knowing roughly where they live. This is an acceptable risk because it is much easier to do efficient onion routing on networks with RRCs than those without meaning that there is no reason not to have all connections onion-routed to some degree, providing better privacy overall.</p>
<p>Other benefits of routing coordinates are that they have the potential to almost completely prevent denial-of-service attacks. To even attempt such an attack, the attacker must find the routing coordinate of their target. Disregarding user error, this kind of attack is essentially impossible since everything is onion-routed by default. Even if the attacker does have the target's routing coordinate, trying to DOS a routing coordinate is like trying to DOS the entire expanse of network between the attacker and the target, the attacker(s) will be ineffective or blocked by other nodes automatically for overuse of the network. Even distributed denial of service attacks can be mitigated with additions to the protocol allowing the victim to notify the network that they are being attacked and to rate limit the attackers.</p>
<h2 id="anonymous-routing-onions-garlic-and-all-the-others"><a class="header" href="#anonymous-routing-onions-garlic-and-all-the-others">Anonymous Routing (Onions, Garlic, and all the others...)</a></h2>
<p>Conventionally, anonymous routing is an incredibly slow ordeal because of how intermediate peers are selected from the network. Due to this inefficiency, onion routing protocols have been somewhat limited in what kind of privacy they can provide because low data rates and high latency was a concern. This is no longer the case with DBR, which may support all kinds of anonymous routing schemes:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Onion_routing">Onion Routing</a>
<ul>
<li>The simplest routing of them all. Simply select a list of peers and establish a route from beginning to end.</li>
</ul>
</li>
<li>Garlic Routing
<ul>
<li>Similar to onion routing, but when sending packets to multiple peers at once, send them together for them to be split apart at some mid-point in the path.</li>
</ul>
</li>
<li>Multi-path routing
<ul>
<li>Maintain multiple Onion routes throughout the network and randomly send packets along all or some subset of them.</li>
</ul>
</li>
<li>Pool Routing
<ul>
<li>Create a group that nodes can join. All nodes randomly send randomly-sized data packets to all other nodes at random intervals, sending real data (padded) if there is data to send and sending random bytes if not.</li>
</ul>
</li>
</ul>
<p>DBR plans to use a modification of the <a href="https://arxiv.org/abs/1507.05724v3">HORNET</a> protocol for setting up fast onion-routed links.</p>
<h2 id="preventing-network-abuse"><a class="header" href="#preventing-network-abuse">Preventing Network Abuse</a></h2>
<p>Routing protocols that rely solely on people voluntarily hosting nodes typically only have a relatively small number of peers willing to route packets through themselves (i.e. TOR). This is why protocols like BitTorrent, I2P and IPFS have systems in place that incentivize peers who use the network to contribute back for the benefit of all.</p>
<p>To accomplish this behavior for DBR there must to be some way to limit packets going through nodes that either don't use the network that much or don't have a lot of bandwidth capacity and speed up packets through nodes that contribute greatly to the network. Also to take into consideration are the management of nodes that have inconsistent uptime or inconsistent routing.</p>
<p>When talking about incentives, we are talking about game theory. So lets analyze the game theoretical situation at the level of an individual node.</p>
<p>Constraints:</p>
<ul>
<li>Each node is directly connected to a fixed number of other nodes at a varying latencies and bandwidth.</li>
<li>Each node wants to send traffic through other nodes to use the network.</li>
<li>Each node wants to establish onion proxies with other nodes for privacy.</li>
<li>Each node has set of parameters that may change over time:
<ul>
<li>Percentage of the time it will immediately respond and route a packet.</li>
<li>Amount of traffic per unit time it is willing to route on average.</li>
<li>Max amount of traffic per unit time it can route.</li>
</ul>
</li>
</ul>
<p>The goal is to allow for unrelated nodes to route and establish proxies through each other in proportion to how much each node contributes in some way to the network.</p>
<p>Ideas:</p>
<ul>
<li>Each node keeps track of the amount of traffic (bytes) flowing through its itself from directly connected nodes.</li>
<li>Each node only sends traffic through direct nodes it knows it has received traffic from.</li>
<li>There is more to theorize about here for future research :)</li>
</ul>
<h1 id="directional-trail-search"><a class="header" href="#directional-trail-search">Directional Trail Search</a></h1>
<p>Directional Trail Search is a protocol that allows one to fetch a piece of data based on its hash (i.e. like IPFS). Unlike IPFS, it does not rely on a Distributed Hash Table (DHT), data can be retrieved anonymously, optionally hosted anonymously, and it is much faster and infinitely more scalable. It achieves this by taking inspiration from nature and allows data to leave trails as it travels through the network. In a network using Distance-Based Routing (DBR), these data trails may be followed to allow anyone to quickly find nodes that may host a specific piece of data.</p>
<h2 id="the-main-idea-1"><a class="header" href="#the-main-idea-1">The Main Idea</a></h2>
<p>When a node wants to make some data available, it broadcasts traversing packets containing the data's hash out in all directions and the nodes that the packet travels through note down what direction the packet came from and the hash contained within.</p>
<p>When another node wants to fetch some data using the hash, it will broadcast its own traversing packet containing the hash to fetch onto the network. These packets will travel in a strait line until they encounter a node that knows whether or not.</p>
<p>Directional Trail Search takes inspiration for how ants find food: scent and pheromone trails. In Dither, these take form as &quot;holes&quot; and &quot;trails&quot;. Holes form when nodes broadcast to nearby nodes (nearby in terms of routing coordinates) that they have the data behind a given hash. Those nearby nodes will then note down the hash and which direction the broadcast came from. Then, when another node wants to find the data of that hash, it will send out many wandering packets [link needed] that will, when encountering a node that has the desired hash, will be routed by that node towards the node that actually has the data that generates the hash.</p>
<p>The other form is &quot;trails&quot;. These form once a wandering packet has finally reached the node with the data it was looking for (the data the matches the hash). This destination node then sends a special traversal packet back to the sending node that tells each node on the way to take note of what direction the traversal packet came from. This forms a kind of trail in the network that other wandering packets can come across and follow to the desired node. This system also creates an effect where the more popular a given piece of data is, the faster a node hosting it will be found.</p>
<p>For data that is not very popular and can't be find found with a reasonable number of wandering packets, a simple DHT can be used to map hashes to route coordinates.</p>
<h2 id="specific-structure"><a class="header" href="#specific-structure">Specific Structure</a></h2>
<p>Every node in Dither will have a binary tree structure that maps hashes to a relative routing direction or a direct peer (TBD).</p>
<h2 id="downsides"><a class="header" href="#downsides">Downsides</a></h2>
<p>While Directional Trail Search is much faster and more efficient than DHTs, it is not as good when considering rare data. With a DHT, as long as there is at least one node hosting the data, it will be found eventually. With DTS, there is no guarantee that a piece of data will be found.</p>
<p>There are multiple potential solutions in order of feasibility:</p>
<ul>
<li>Use a DHT in addition to DTS by default</li>
<li>Figure out how to get DTS to support rare files natively, perhaps by making nodes send out traversal packets pointing to themselves along the network to create artificial paths.</li>
<li>Store routing coordinates / routing areas on the Reverse Hash Lookup.</li>
<li>Implement a Network Coordination feature that tells all nodes in the network to notify a node when they find the requested data. (induces denial of service vector, probably a bad idea)</li>
</ul>
<h1 id="reverse-hash-lookup-wip"><a class="header" href="#reverse-hash-lookup-wip">Reverse Hash Lookup (WIP)</a></h1>
<ul>
<li>This solves the problem of having a hash and wanting to find pieces of data that link to that hash. This is super useful for comment systems and the like.</li>
<li>This is a system by which one can find structures that link to a given hash implementing the reverse trait.</li>
<li>If there is some pieces of data that links from or adds useful definitions to a given piece of data, this is the place for it. One example of this in practice might be having a comment thread. Each comment is its own Hashtype that contains the hash of the post or a replying comment. In order for someone who has the post structure to find the comments, they would need find all the pieces of data linking to this piece of data (i.e. a Reverse Hash Lookup)</li>
<li>To implement this system, there will be a partial binary tree represented by a DAG that can be traversed using the data of the target. (i.e. the post structure's hash). Then the tree can be traversed down using consecutive trail searches. Until a list of all known linked hashes is found. These structures must contain a specific trait called a RevHash to be able to be validated onto the distributed tree. The addition of new links to this tree is done through an implementation of Dither Chain Consensus (see the <a href="dither/data/reverse-hash-lookup.html#dither-consensus-chains">#Dither Consensus Chains</a> section).</li>
</ul>
<p>Allows for finding what structures link to a given structure.</p>
<p>Example: Someone can find a comment that links to a post, just given the hash of the post.</p>
<h1 id="ideas-to-add"><a class="header" href="#ideas-to-add">IDEAS TO ADD</a></h1>
<p>Keep track of the number of child nodes for each node in the tree so you can merge reverse hash lookup trees easily in a peer-to-peer fashion which means consensus can be less rigourous.</p>
<h2 id="general-structure"><a class="header" href="#general-structure">General Structure</a></h2>
<p>A binary hash-linked search tree stored in a decentralized fashion with <a href="dither/data/../routing/directional-trail-search.html">DTS</a> that maps a given hash to object that contains that hash. Hashes are agreed upon in a decentralized manner, but direct consensus is assured, and a pubsub system helps speed up consensus for high-activity hashes.</p>
<h2 id="specific-structure-1"><a class="header" href="#specific-structure-1">Specific Structure</a></h2>
<h3 id="tree"><a class="header" href="#tree">Tree</a></h3>
<ul>
<li>The goal for this tree is for nodes to contain as little information as possible so that large portions of the tree can be sent at once.</li>
<li>A Binary Tree contains <code>Branch</code>es and <code>Node</code>s. For this structure, each one will be its own self-defining structure. Each node will contain</li>
<li>Binary Tree, contains</li>
</ul>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<ul>
<li>
<p><code>Node&lt;T, L&gt;</code> - Nodes of the tree</p>
<ul>
<li><code>subnodes: List&lt;T, L&gt;</code> - subnodes of this node</li>
</ul>
</li>
<li>
<p><code>Leaf</code> - </p>
</li>
<li>
<p>This is a system by which one can find structures that link to a given hash implementing the reverse trait.</p>
</li>
<li>
<p>If there is some pieces of data that links from or adds useful defintions to a given piece of data, this is the place for it. One example of this in practice might be having a comment thread. Each comment is its own Hashstruct that contains the hash of the post or a replying comment. In order for someone who has the post structure to find the comments, they would need find all the pieces of data linking to this piece of data (i.e. a Reverse Hash Lookup)</p>
</li>
<li>
<p>To implement this system, there will be a partial binary tree represented by a DAG that can be traversed using the data of the target. (i.e. the post structure's hash). Then the tree can be traversed down using consecutive trail searches. Until a list of all known linked hashes is found. These structures must contain a specific trait called a RevHash to be able to be validated onto the distributed tree. The addition of new links to this tree is done through an implementation of Dither Chain Consensus (see the <a href="dither/data/reverse-hash-lookup.html#dither-consensus-chains">#Dither Consensus Chains</a> section).</p>
</li>
</ul>
<h1 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero Knowledge Proofs</a></h1>
<p>These are really cool btw.</p>
<p>Potential Applications:</p>
<ul>
<li>Anonymous Transactions</li>
<li>Proof of Karma (proove that someone is trustworthy enough on the Dither network for them to be trusted without giving away more information than necessary)</li>
<li>KYC/18+ requirements - For abiding by laws.</li>
<li>(Is this even possible?) - Proove that some well-defined operation was done correctly on a given piece of data, i.e. that a binary was compiled correctly with no tampering.</li>
<li>Prooving that a given Self-Defined Structure's valid proof is valid.</li>
<li>Anonymous Auctions (Hiding what other people bid for items)</li>
</ul>
<p>Potential Traits:
``</p>
<h1 id="dithers-user-api"><a class="header" href="#dithers-user-api">Dither's User API</a></h1>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>Dither is aiming to replace the internet, so it needs a standard method of accounting. This includes storing user data publicly and privately, identifying users, and authenticating users. These accounts need to be able work across devices and should have varying levels of authentication for varying levels of storage of information.
Dither accounts should also be able to prove qualities about themselves to external parties using zero-knowledge proofs.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>Accounts should be able to be accessed in a standard way that is accessible to any application.</p>
<p>Accounts should have multiple levels of authentication for varying levels of access to information.</p>
<p>Accounts should be able to expose however much information their users want.</p>
<ul>
<li>Whether it be a throwaway anonymous account or an account connected to every aspect of a person's life.</li>
</ul>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p>A user is just a Public / Private key pair with encrypted and unencrypted data stored in a versioned data structure.</p>
<p>There are two parts to this datastructure, a public versioned structure and a private encrypted structure. The public key is stored in the public structure, the private key is stored in the private structure. </p>
<p>Any interaction between an application and a user on Dither is done through the Dither API. Applications can create users, authenticate as a user and discover the public data of other users through the User API.</p>
<h2 id="user-definitions"><a class="header" href="#user-definitions">User Definitions</a></h2>
<p>These public and private structures can have various definitions that define various qualities about the user. Definitions are just permissioned data that is stored by a user. Definitions can be publicly available, publicly writable or conditionally available, and writable with specific permissions.</p>
<h3 id="examples-of-definitions"><a class="header" href="#examples-of-definitions">Examples of Definitions</a></h3>
<ul>
<li>Public
<ul>
<li>Username</li>
<li>Autobiography</li>
</ul>
</li>
<li>Private</li>
</ul>
<h2 id="user-api"><a class="header" href="#user-api">User API</a></h2>
<p>Application </p>
<ul>
<li><code>CreateUser()</code>
<ul>
<li>Create new user (for permanent or temporary purposes)</li>
<li>This will create a new user in this peer and give access to application that called this DitherAction</li>
</ul>
</li>
<li><code>Bootstrap(PeerID, MultiAddr)</code>
<ul>
<li>Tell network layer to bootstrap to specific node (only used on startup)</li>
</ul>
</li>
<li><code>Discover(UserId)</code>
<ul>
<li>Initiate a network tree request to discover info about a user. (e.g. hosting peers, public configuration)</li>
<li>Depending on the queried user’s config information may or may not be returned.</li>
</ul>
</li>
<li><code>Authenticate(UserId, UserToken)</code> - Authenticate to user on dither network
<ul>
<li>This will attempt to authenticate an application as a user on the network. </li>
<li>When a token is sent to the peer(s) with permission over the user’s private key, the type of authentication is predetermined by the permissions in the private user configuration. The Types of Authentication are:
<ul>
<li>Hosting - the user’s private key is sent to the application and the application has full control over the user</li>
<li>Proxy - all events are sent through peers with actual permission to sign messages</li>
</ul>
</li>
<li>Will attempt to authenticate as a known user with known hosting peer</li>
</ul>
</li>
<li><code>SendData(UserId, Data)</code>
<ul>
<li>Send data to specific application of specific UserId</li>
<li>Can potentially be a local application (such as dither-scp or dither-db)</li>
<li>Or another dither service running on another peer</li>
</ul>
</li>
</ul>
<h1 id="the-dither-project-1"><a class="header" href="#the-dither-project-1">The Dither Project</a></h1>
<ul>
<li><a href="dither.html#the-dither-project">The Dither Project</a>
<ul>
<li><a href="dither.html#what-is-it">What is it?</a></li>
<li><a href="dither.html#a-plan-for-the-future-of-the-internet">A Plan for the Future of the Internet</a></li>
</ul>
</li>
<li><a href="dither.html#core-tenets">Core Tenets</a></li>
<li><a href="dither.html#structure">Structure</a>
<ul>
<li><a href="dither.html#core-process">Core Process</a></li>
<li><a href="dither.html#service-swarm">Service Swarm</a></li>
<li><a href="dither.html#user-interface">User Interface</a></li>
<li><a href="dither.html#interface-layer">Interface Layer</a></li>
</ul>
</li>
<li><a href="dither.html#other-links">Other Links</a>
<ul>
<li><a href="dither.html#inspirations-for-dither">Inspirations for Dither</a></li>
</ul>
</li>
</ul>
<h2 id="what-is-it-1"><a class="header" href="#what-is-it-1">What is it?</a></h2>
<p>Dither is a project with the goal of decentralizing the internet. It is a toolbox of various tools application developers can use to communicate privately, host data, manage accounts much more. It is currently being developed by <a href="https://github.com/zyansheep">@Zyansheep</a> and temporarily hosted via GitHub under the <a href="https://github.com/libdither">libdither</a> organization.</p>
<h2 id="a-plan-for-the-future-of-the-internet-1"><a class="header" href="#a-plan-for-the-future-of-the-internet-1">A Plan for the Future of the Internet</a></h2>
<p>The plan behind Dither is to create an modern internet unencumbered by any kind of central control. To accomplish this, Dither must somehow replace existing apps and services <em>by outcompeting them</em>. This is an incredibly monumental task, but there are some things that may help in Dither's favor.</p>
<ul>
<li><strong>No Hosting Costs</strong> — Being decentralized means the users host everything. If we can create a system to make it as painless as possible to host data, that would be ideal.</li>
<li><strong>Redesigning Everything is Sometimes Good</strong> — If applications using Dither are fundamentally better designed than the alternative and it is easy to switch, users will be more likely to use them.</li>
<li><strong>No Intellectual Property</strong> — Intellectual property protections do not apply to the core of Dither since it is a peer-to-peer network. This means that new platforms can be immediately populated with any existing content people might want to watch. Note: Precautions should be taken to make sure creators have a say in if they want their content to be shown on mainstream applications using the protocol to prevent public backlash.</li>
<li><strong>Standardization</strong> — Dither's ecosystem of APIs will all be compatible with each other which will infinitely improve the experience of the user. (Imagine being able to use a Discord-like chat room or a Reddit-like comment system underneath a YouTube video, or really any kind of system you want. It's all modular!).</li>
<li><strong>Natural Incentives</strong> — Similar to Brave browser's tipping system, If applications built on Dither have good incentive systems for content creation that extends to existing content, then creators whose content is uploaded to the network will automatically accrue income that will then be an incentive for them to claim their money and create an account. Unlike Brave, there won't be any KYC requirements :).</li>
</ul>
<p><em>The aim for Dither is to replace existing centralized applications with decentralized alternatives that are unified through their use of a singular, modular protocol.</em></p>
<p>See the <a href="applications.html">application document</a> for outlines of various applications that could be built using Dither.</p>
<h1 id="core-tenets-1"><a class="header" href="#core-tenets-1">Core Tenets</a></h1>
<p>It seems necessary for projects to have guidelines so that everyone may be on the same page. These are the ones I've chosen for now, as with everything, they are subject to change.</p>
<p><strong>Dither should be as modular as possible.</strong></p>
<ul>
<li>Reasoning: There should be no part of Dither that is difficult to replace with a different implementation and people should be able to pick and choose which parts they want.</li>
</ul>
<p><strong>Dither protocols, formats, and communities should be as interoperable as possible with existing protocols, formats, and communities</strong></p>
<ul>
<li>Reasoning: To grow Dither's userbase, It should be as easy as possible to transition to Dither from other services.</li>
<li>One example of this would be allowing someone to pull comments from Reddit / Youtube into <a href="applications/dithca.html">Dithca</a> and hosting them in a decentralized manner.</li>
<li>Another example might be <a href="applications/dithca.html">Dithca</a> storing Reddit credentials and being able to optionally interact with comment threads pulled from centralized websites.</li>
</ul>
<p><strong>Dither should rely on itself as much as possible for every aspect of development and usage.</strong></p>
<ul>
<li>Reasoning: It feels natural for a program to use itself if possible. Rust is written in itself, GitLabs is hosted using GitLabs, etc.</li>
<li>Code Versioning, Storage, Building, Distribution, and Social communication should all run through Dither applications if it won't compromise development too much.</li>
</ul>
<h1 id="structure-3"><a class="header" href="#structure-3">Structure</a></h1>
<p>Following the first tenet of Dither, in the future the lines between these layers will blur and everything will be a module. However, the design of current operating systems don't easily allow for shared code and data, requiring a more formal structure. In the future this layered structure will be replaced with a more <a href="dither/structure.html">flexible system</a>.</p>
<h2 id="core-process-1"><a class="header" href="#core-process-1">Core Process</a></h2>
<p>The Core Dither Process is the part that deals with all operating system-facing operations such as data storage, establishing peer-to-peer connections with other computers, in addition to managing all Dither services and connections between them.</p>
<p>This &quot;Core Process&quot; provides a few core APIs that only certain services running in the &quot;Service Swarm&quot; are allowed to use for security purposes. The idea behind a &quot;Core Process&quot; is to create a sandboxed environment for services to run in a safe manner.</p>
<p>peer-to-peer connections with other computers running Dither.
Currenly in the dither-sim program, this is implemented via a simple TCP stream. In the future this layer will be implemented using existing libraries such as <a href="https://libp2p.io/implementations/#transports">libp2p transports</a>, <a href="https://www.pluggabletransports.info/transports/">Pluggable Transports</a>, something else, or some amalgamation of all three. The idea behind this layer is to provide as many methods of communication as feasibly possible.</p>
<h2 id="service-swarm-2"><a class="header" href="#service-swarm-2">Service Swarm</a></h2>
<p>The service layer provides all functionality related to <a href="dither/routing/distance-based-routing.html">routing</a>, encryption, <a href="dither/routing/directional-trail-search.html">data storage</a>, <a href="dither/data/user-management.html">user management</a> and everything else. Each of these services are split up into separate modules each of which runs its own processes and communicates with other services through inter-process communication. </p>
<p>All these processes are managed as child processes under one &quot;main process&quot;. The main process contains the Transport Layer implementation, the routing protocol API and APIs for managing the child services as well as managing inter-process communication between child processes.</p>
<h2 id="user-interface-1"><a class="header" href="#user-interface-1">User Interface</a></h2>
<p>The application layer contains services just like the service layer that are registered under the main process. These registered service's APIs can be used by other applications. </p>
<p>The application layer also refers to the application's core API, which is used by the interface layer. This &quot;core application API&quot; can be built into the applicaiton's executable, or it can run as a service under the main process and used by multiple interfaces. This is left up to the application developers. Applications with multiple interfaces should prefer to register application APIs under the main process.</p>
<p>Existing planned applications may be found <a href="applications.html">here</a>.</p>
<h2 id="interface-layer-1"><a class="header" href="#interface-layer-1">Interface Layer</a></h2>
<p>The final layer is the interface layer. This just refers to standalone applications that provide some kind of interface to the user using the services running under Dither.</p>
<p>These interfaces can be implemented however, but it is recommended for them to follow Dither's <a href="dither/application-design-philosophy.html">application design philosophy</a> for some level of standardization.</p>
<h1 id="other-links-1"><a class="header" href="#other-links-1">Other Links</a></h1>
<h3 id="a-hrefditherinspirationshtmlinspirations-for-dithera-1"><a class="header" href="#a-hrefditherinspirationshtmlinspirations-for-dithera-1"><a href="dither/inspirations.html">Inspirations for Dither</a></a></h3>
<p>Dither as with any creative endeavor takes inspiration from many other projects. This is a list of what parts of Dither have been inspired from other projects.</p>
<h1 id="disp-decentralized-lisp"><a class="header" href="#disp-decentralized-lisp">Disp (Decentralized Lisp)</a></h1>
<p><em>What is a program? What is data? Why, they are one of the same.</em></p>
<p>Inspired by:</p>
<ul>
<li>Lisp for its flexibility</li>
<li>Idris &amp; Coq for the infinite expressiveness of dependent types</li>
<li>Rust for its speed</li>
<li>IPFS for deduplication</li>
</ul>
<h2 id="goals-1"><a class="header" href="#goals-1">Goals</a></h2>
<p>A general outline of the (very lofty) goals of Disp.</p>
<ul>
<li>Most efficient language to run</li>
<li>Support for any cpu or interpreter</li>
<li>Most efficient language to write
<ul>
<li>Projectional Editing
<ul>
<li>Localization-agnostic naming</li>
</ul>
</li>
<li>Mixable syntax
<ul>
<li>Transpilation from any other language</li>
</ul>
</li>
</ul>
</li>
<li>Seamless integration into Dither</li>
</ul>
<h2 id="core-ideas"><a class="header" href="#core-ideas">Core Ideas</a></h2>
<ul>
<li><a href="disp/universal-system-of-types.html">Universal System of Types</a></li>
<li>[Binding Trees]</li>
</ul>
<h2 id="ideas"><a class="header" href="#ideas">Ideas</a></h2>
<ul>
<li>Objects are stored in self-defining data structures, i.e. they link to data that describes the format of the object (whether that be structurally, in-memory, or symbolically).
<ul>
<li>An object can be defined by its computation -&gt; Compilation can be as incremental as you want.</li>
<li></li>
</ul>
</li>
<li>High level programs are provably compiled into arbitrary lower-level representations with minimal programmer input.
<ul>
<li>An inductive datatype like <code>Nat</code> could be provably compiled into something like <code>BigInt</code> and be much more efficient. In tern, as long as you either ignore the possibility or proove it never happens, <code>BigInt</code> could be transformed into a  <code>U64</code> or something similar.</li>
</ul>
</li>
<li>Goal of compilation is cpu-specific object file complete with
<ul>
<li>data pre-loaded into memory</li>
<li>list of cpu-specific instructions.</li>
<li>hash of external virtual kernel API (i.e. syscall functions)</li>
</ul>
</li>
<li>virtual kernel APIs can be constrained to give programs access to different parts of the computer, or forgone entirely for programs that only manipulate data.</li>
<li>Running object files requires a uniquely setup syscall kernel API that can deal with interrupts</li>
</ul>
<h2 id="general-architecture"><a class="header" href="#general-architecture">General Architecture</a></h2>
<ul>
<li>
<p>There are two structures that are core to disp: <code>Expr</code>, and <code>Judgement</code>. <code>Expr</code> is an inductive structure that represents all the terms and types of the language. <code>Judgement</code> is the structure that matches <code>Expr</code>s together to create a typing judgement (i.e. saying some term is of some type or <code>a : A</code>). See [[expr]] for more details.</p>
</li>
<li>
<p>All structures of the language are defined through [[hashtypes]] </p>
</li>
<li>
<p>All language types are themselves self-defining structures, including the final bytecode file.</p>
</li>
<li>
<p>The language files are not stored as text files, they are instead stored as self-defining structures of groups of commands.</p>
</li>
</ul>
<h1 id="universal-system-of-types"><a class="header" href="#universal-system-of-types">Universal System of Types</a></h1>
<blockquote>
<p>a type system is a logical system comprising a set of rules that assigns a property called a type to every &quot;term&quot;</p>
</blockquote>
<p>Who choses the rules that assign types to terms? What makes one set of rules better than another? Some type systems are more general than others, some are more easily compiled into efficient bytecode, some allow for writing complex mathematical proofs. Exactly how large is this design space?</p>
<p>Disp captures the entire design space of possible type systems by generalizing the concept of types:</p>
<p><em>To make a long story short, a type is simply a program that returns true, false, or loops forever when given the source code of another program.</em></p>
<p>This allows the programmer to define their own type system in Disp. Or just use a pre-made one.</p>
<h2 id="the-implementation"><a class="header" href="#the-implementation">The Implementation</a></h2>
<p>In disp, every term is stored in a <a href="disp/names.html">context</a> as a judgement that contains a term and a type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Judgement {
	term: Expr,
	ty: Expr,
}
<span class="boring">}
</span></code></pre></pre>
<p>To verify if a judgement is valid and may be stored in a context, the compiler encodes the term using simple church-encoded data structures (like tuples and sums). The encoded form is then applied to the <code>ty</code> expression and beta-reduced. The judgement is considered valid if the expression reduces to <code>Expr::Var</code>.</p>
<h1 id="type-system-of-disp"><a class="header" href="#type-system-of-disp">Type System of Disp</a></h1>
<p>While the type system of Disp can be literally <a href="disp/universal-system-of-types.html">any computable program</a>, disp will have its own standard type system defined in the standard <a href="disp/names.html">context</a> that will allow for the creation of programs optimisable to a level at or beyond the speed of C and Rust.</p>
<p>The standard type system for disp should be:</p>
<ul>
<li>Simple
<ul>
<li>Relatively few core inference rules</li>
<li>More complex types are constructed from a few simple primitive type constructors.</li>
</ul>
</li>
<li>Fast
<ul>
<li>Types that reflect hardware primitives (such as machinecode) should be representable and the type system should be able to reason about equivalence between inefficient high-level types and efficient low-level types.</li>
</ul>
</li>
<li>Consistent
<ul>
<li>Logic of types should be consistent</li>
<li>Type checking should never loop indefinitely</li>
</ul>
</li>
<li>Representative
<ul>
<li>The standard type system for Disp aims to be a viable foundation for all of mathematics.</li>
</ul>
</li>
</ul>
<h2 id="substructural-types"><a class="header" href="#substructural-types">Substructural Types</a></h2>
<p>For a systems language, runtime overhead must be kept to a minimum. This means that the restrictions on lifetime and movability of heap and stack allocations should be modeled and enforced at compile time, instead of relying on a runtime methods such as garbage collection or reference counting.</p>
<p>Disp uses a type system that divides terms and types into 3 categories:</p>
<p>Unrestricted</p>
<ul>
<li>This includes most types, type constructors, and terms that can fit in a single CPU register.</li>
<li>Unrestricted objects may be moved around and duplicated at will in a program and don't require a specific function defining how they are deallocated.</li>
</ul>
<p>Linear</p>
<ul>
<li>This includes terms allocated on the heap, mostly structures with variable-length allocations.</li>
<li>Linear objects must be used in each context exactly once and must define at least one destructor or else it won't typecheck.</li>
<li>Linear objects may contain unrestricted objects, just like how heap-allocated objects may contain numbers that can be stored in registers.</li>
<li>Examples: ATS, Rust kinda</li>
</ul>
<p>Ordered</p>
<ul>
<li>This includes any term allocated on the stack, which is pretty much anything else.</li>
<li>Ordered objects must be used in each context exactly once and can only be used in reverse-order of allocation (like a stack).</li>
<li>Ordered objects may contain unrestricted or linear objects.</li>
<li>Examples: <a href="https://binji.github.io/posts/webassembly-type-checking/">Webassembly</a>, Porth</li>
</ul>
<p>A paper outlining a potential framework for a type system unifying all 3 of these substructural modes can be found <a href="https://mitpress-request.mit.edu/sites/default/files/titles/content/9780262162289_sch_0001.pdf">here</a>.</p>
<h2 id="minimal-type-theory"><a class="header" href="#minimal-type-theory">Minimal Type Theory</a></h2>
<p>In order for Disp to be able to double as a general-purpose theorem prover, the ideas from <a href="https://www.math.unipd.it/%7Esambin/txt/MaiettiSambin-rev2.pdf">this paper</a> describing a Minimal Type Theory (mTT) may be used.</p>
<h2 id="inspiration"><a class="header" href="#inspiration">Inspiration</a></h2>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=zt0OQb1DBko">ATS Language</a></p>
</li>
<li>
<p><a href="https://mitpress-request.mit.edu/sites/default/files/titles/content/9780262162289_sch_0001.pdf">Substructural Type Systems</a></p>
</li>
<li>
<p><a href="https://www.math.unipd.it/%7Esambin/txt/MaiettiSambin-rev2.pdf">Towards a Minimalist Foundation for Constructive Mathematics</a></p>
</li>
</ul>
<h1 id="syntax-agnosticism"><a class="header" href="#syntax-agnosticism">Syntax Agnosticism</a></h1>
<p>Syntax is one of the most visible barriers separating different languages from each other. It is easy to distinguish between Lisp and C, BASIC and APL, Haskell and Fortran. All these languages can pretty much do the same things, but their different syntax plays a big role in preventing programmers experienced in one from trying out another.</p>
<p>Disp aims to solve this issue by allowing the programmer to use whatever syntax style they prefer. This is possible because Disp is not stored in text files, it is instead temporarily rendered to a text file in a given syntax style and then parsed back to a structured binary format. Syntax styles should be compatible with each other and switching between them should be as simple as a click of a button.</p>
<h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>Since Disp has <a href="disp/syntax-agnosticism.html">Syntax Agnosticism</a>, it does not require one set syntax. For consistency and branding purposes however, Disp will have its own succinct and readable default syntax. This </p>
<p>Disp's default syntax is still a work-in-progress, however I think I want something similar to lisp with various Rust conventions sprinkled in.</p>
<pre><code>// By itself, this is a comment
// It doubles as documentation when paired with an object

// This is an object, its type in inferred.
set Unit ();

// The function type is a function that takes two types A and B and returns a dependent product type where B is *not* dependent on a term of A.
set -&gt; λ[A B] Π[_:A] B
set /\ λ[A B] Π[C:Type] (A -&gt; B -&gt; C) -&gt; C
set id_type Π[A: Type] A -&gt; A
set id λ[t] λ[x] x : id_type

// Pair constructor
set pair_type Π[A: Type, B: Type] A -&gt; B -&gt; C
set pair λ[x y f] f x y

set Bool Π[A: Type] A -&gt; A -&gt; A {
	true: λ[x y] x
	false: λ[x y] y
}







</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code>// This is a comment, it also doubles as documentation

// Variables
(set ten 10:b64)

// variable names can have most symbols in them
(set ten? 10) // literal 10 resolves to 10:bsize

(use std::flow::assert)
(assert_exact ten ten?) // =&gt; true only on 64-bit systems, because bsize = b64
(assert_eq ten ten?) // =&gt; always true

// Reason about functions
(use std::code::compile)
(assert_exact
	// Parentheses implied
	compile `(a b) `(assert_eq a b) 
	compile `(a b) `(panic_if (!= a b))
	compile `(a b) `(if (= a b) (panic))
) // =&gt; these functions are the exact same when compiled

// Strings
(set string &quot;Hello, World!&quot;) // implies &quot;Hello, World!&quot;:String

// String declaration follows the same declaration convention as Rust, except that Strings are stack-allocated by default.
(print string) // =&gt; prints out &quot;Hello, World!&quot;
(print &quot;And the God of Programming said: {:?}&quot; string) // =&gt; prints out formatted string with debug representation of string.

// Type definition (with type macro)
(type SomeStruct
	number b64
	_ (String Character)
)

// This macro resolves to something similar to using the formats of Type and TypeLocalization hashtype.
(set SomeStruct ( (hash b64) ( (hash String) (hash Character)):Type))
(set SomeStructLocalization ((hash SomeStruct) ):TypeLocalization)

// Trait definition using trait macro
// A trait defines a collection of adjacent data (either a function, or a value) that is attached to a Type
(trait SomeTrait
	fn size (&amp;self) (usize)
)

(impl AddOne SomeStruct
	set add_one (fn (~self) (self) (
		(inc (loc self number) 1)
		(self)
	))
)

// Initiate SomeStruct with values
// symbol = thing notation is equivalent to (set symbol thing)
some_struct = (1098342 (&quot;Hello, World!&quot;, 'u')):SomeStruct

(some_struct size)

(1098342:B64 -12304: String:&quot;hello there&quot; Symbol:hello)
</code></pre>
<h1 id="names"><a class="header" href="#names">Names</a></h1>
<h2 id="a-natural-idea"><a class="header" href="#a-natural-idea">A Natural Idea</a></h2>
<p>A word in a language is a label to which we assign a definition. These definitions may be physical or abstract, but in a programming languages: a definition is a piece of code.</p>
<p><code>let id = λx . x</code> - We are fitting the label &quot;id&quot; to the definition <code>λx . x</code></p>
<p>Words in natural languages may have more than one definition. When using these words in conversation however, typically only one definition is intended by the speaker. The definitions and names we use in conversation are set by the <em>context</em> of the conversation to which the speaker hopes the listener has deduced correctly. </p>
<p>Contexts also exist in programming languages. Namespaces, modules, classes. Unlike real conversation where contexts can be deduced from various cues, computers need to know exactly what definition a label corresponds to and can't just &quot;figure it out&quot; (yet). A context in a programming language is meticulously organized hierarchy of modules. When using these modules, programmers have to specifically import names into the context of their code, requiring the programmer to keep in their head where in the module hierarchy all the names they need to use are.</p>
<p>Contrast this to how we deal with context in natural languages, where when starting a conversation, we assume don't assume what the single definition of a given word will be without first inferring a context from surrounding cues. For example if we are talking garnishing food, you might be referring to adding things whereas if we are talking about garnishing wages, we are talking about taking away. This is the way our brains are used to dealing with context, so it puts a special strain on the programmer where a complex pre-defined hierarchy must be memorized to actually program effectively.</p>
<p>The goal: Remove this burden on the programmer by resolving names from the context of the program.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A perfect way to model resolving from contexts is to use a <a href="https://en.wikipedia.org/wiki/Knowledge_graph">knowledge graph</a>. A name may resolve to many different expressions, but the scope of possibilities may be restricted further by the context of the types of surrounding types or specifically declared contexts.</p>
<h1 id="structure-4"><a class="header" href="#structure-4">Structure</a></h1>
<p>Names and programs in Disp are separate, this is so that alpha-equivalence is preserved and so that the same program may be able to named differently by different people.</p>
<p>A program is represented by an <a href="disp/expr.html"><code>Expr</code></a>. A Named program is represented by a <code>NamedExpr</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Expr {
	Abs { binding: Binding, expr: Expr },
	App { func: Expr, args: Expr }
	Var,
}
struct NamedExpr {
	name: String,
	expr: NameTree,
}
enum NameTree {
	Abs { bind_name: String, expr: NameTree }, // For Abs and Pi binding
	App { left: NameTree, right: NameTree } // For App
	Name(NamedExpr)
	End,
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="modular-parsing"><a class="header" href="#modular-parsing">Modular Parsing</a></h1>
<h1 id="hardware-modeling"><a class="header" href="#hardware-modeling">Hardware Modeling</a></h1>
<h4 id="how-do-we-generate-fast-code"><a class="header" href="#how-do-we-generate-fast-code">How do we generate fast code?</a></h4>
<ul>
<li>Currently, Optimizing Compilers generate fast code through intermediate representations and various techniques to figure out what code is needed and what code is not.
<ul>
<li>https://www.lihaoyi.com/post/HowanOptimizingCompilerWorks.html</li>
</ul>
</li>
<li>These strategies are mostly arbitrary and not easily improvable. A programmer has to go through and figure out which optimizations are worth the compiler computation cost and which aren't. There are an immeasurable number of trade-offs and potential improvements for a given piece of hardware. This calls for a new method to quantify these trade-offs and create a better system.</li>
</ul>
<h4 id="how-do-we-create-fast-algorithms"><a class="header" href="#how-do-we-create-fast-algorithms">How do we create fast algorithms?</a></h4>
<ul>
<li>We typically manually write algorithms we think will run fast and then compare them to other algorithms using benchmarks. However, benchmarks have so many confounding factors that it is difficult to compare two of them and make definitive conclusions.
<ul>
<li>Results may also depend on whether the algorithm is fit for the CPU architecture. The same algorithm may run faster or slower depending on a bazillion different factors such as <a href="https://www.youtube.com/watch?v=r-TLSBdHe1A">layout</a></li>
</ul>
</li>
</ul>
<h2 id="how-to-model-performance"><a class="header" href="#how-to-model-performance">How To Model Performance</a></h2>
<p>To create efficient code, we must have a model of how that code is run. Typically this model is held in the programmer's mind and is expressed through compiler and algorithm design. Instead of holding it in our forgetful, biased brains, it might be a good idea to have a software-defined model of our hardware so that we can prove that our optimizations and algorithms are actually faster.</p>
<p>Model specifications &amp; options</p>
<ul>
<li>Should take into account modern CPU features such as: pipelining, superscalar execution, out-of-order execution, and branch prediction.</li>
<li>Should be generic enough to model different CPU generations of the same architecture.</li>
<li>Should take into account other hardware qualities such as RAM latency, GPU parallelization options, and any other model-able aspect that could influence performance.</li>
<li>Simple models could be hand-crafted using published characteristics from documents like the <a href="https://www.agner.org/optimize/#manual_instr_tab">Instruction Tables</a></li>
<li>More sophisticated models could be made for open source CPU architectures by using the logic gate layout of the CPU. (This may be possible for architectures like RISC-V)</li>
</ul>
<p>Benefits to this approach include:</p>
<ul>
<li><strong>No more annoying benchmarks</strong> Faster algorithms can be provably faster for a given model.
<ul>
<li>Note: Benchmarks still need to be used to compare different models of a hardware system, however these benchmarks can be much more sophisticated and take into account more confounding factors.</li>
</ul>
</li>
<li><strong>Faster optimization adoption</strong> Compilers can substitute old optimizations for faster ones without delay using a public distributed database of optimization.
<ul>
<li>Scenario
<ul>
<li>Bob has a new optimization for a certain pattern of functional expressions.</li>
<li>Bob proves it is faster for a well-trusted model of x86_64 CPUs</li>
<li>Bob broadcasts optimization to everyone</li>
<li>Everyone checks the proof that it is faster</li>
<li>Everyone uses new optimization, programs are faster</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="hashtypes"><a class="header" href="#hashtypes">Hashtypes</a></h1>
<p>Hash types are how Dither deals with data. </p>
<p>A fundamental property of hash types are that they describe their own domain. This includes: what data types make up the domain (i.e. bytes, types, other data types) and how those datatypes may be restricted (i.e. a data type might be variable in length depending on another type like a list).</p>
<h2 id="fundamental-types"><a class="header" href="#fundamental-types">Fundamental Types</a></h2>
<p>There are a few fundamental types.</p>
<h3 id="multihash-type"><a class="header" href="#multihash-type"><code>Multihash</code> type</a></h3>
<h3 id="expr-type"><a class="header" href="#expr-type"><code>Expr</code> type</a></h3>
<p>Reflects Lambda Calculus</p>
<p>Expr can be interpreted as 3 things:</p>
<p>Bind Variant: (Varint)</p>
<p>Lambda Variant: (<code>Multihash&lt;Expr&gt;</code>, <code>Multihash&lt;Expr&gt;</code>)</p>
<p>Application Variant: </p>
<h3 id="type-type"><a class="header" href="#type-type"><code>Type</code> type</a></h3>
<h3 id=""><a class="header" href="#">`</a></h3>
<h1 id="fundamental-constructs"><a class="header" href="#fundamental-constructs">Fundamental Constructs</a></h1>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Expressions in Disp are programs and match the untyped lambda calculus. They are represented as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Expr {
	Var,
	Lam { bind: Binding, expr: Expr },
	App { func: Expr, func: Expr },
}
enum Binding {
	None,
	End,
	Branch(Binding, Binding),
}
<span class="boring">}
</span></code></pre></pre>
<p>See how the <code>Binding</code> structure works <a href="disp/./bind-trees.html">here</a>.</p>
<h2 id="judgements"><a class="header" href="#judgements">Judgements</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Judgement {
	term: Expr,
	ty: Expr,
}
<span class="boring">}
</span></code></pre></pre>
<p>Judgements are considered valid if when the structure of <code>term</code> is encoded into the lambda calculus, and <code>Expr::App(ty, encoding)</code> beta-reduces to <code>Expr::Var</code>.</p>
<h2 id="contexts"><a class="header" href="#contexts">Contexts</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context {
	names: Map&lt;String, Judgement&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="bind-trees-a-deduplication-friendly-alternative-to-de-brujin-indicies"><a class="header" href="#bind-trees-a-deduplication-friendly-alternative-to-de-brujin-indicies">Bind Trees: A deduplication friendly alternative to De Brujin Indicies.</a></h1>
<p>Used in [Disp]</p>
<p>The current most well known way of representing the lambda calculus is <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Brujin Indicies</a>.</p>
<p>This is where you have 3 variants of a term:</p>
<ul>
<li><code>Var(Number)</code> - Number represents how many layers of abstraction (lambdas) the variable is away from its intended binding</li>
<li><code>App(Term, ...)</code> - Application is a list of Terms</li>
<li><code>Lam(Term)</code> - Lambda represents an abstraction point</li>
</ul>
<p>An example of what this might look like for common equations:</p>
<ul>
<li><code>λx . x</code> = <code>Lam(Var(1))</code></li>
<li><code>λx. λy. x</code> = <code>Lam(Lam(Var(2)))</code></li>
<li><code>λx. (x (λx . λy . x) (λx . λy . y))</code> = <code>Lam(App(Var(1), Lam(Lam(Var(1))), Lam(Lam(Var(2)))))</code></li>
</ul>
<p>For Disp, I have devised an alternative method that doesn't require integers (and thus is not limited by encoding constraints)</p>
<p>Disp has the same 3 variants of Term:</p>
<ul>
<li><code>Var</code></li>
<li><code>App(Term, Term)</code></li>
<li><code>Lam(Binding, Term)</code></li>
</ul>
<p>In addition to a construct Binding:</p>
<ul>
<li><code>None</code></li>
<li><code>End</code></li>
<li><code>Branch(Binding, Binding)</code></li>
</ul>
<p>In fact, the Binding datastructure can be repurposed from the Term datastructure.
<code>(End = Var, None = Lam(Var, Var), Branch(Binding, Binding) = App(Term, Term))</code></p>
<p>Common equation examples of this structure might look like:</p>
<ul>
<li><code>λx . x</code> = <code>Lam(Var, Var)</code></li>
<li><code>λx. λy. x</code> = <code>Lam(Var, Lam(None, Var))</code></li>
<li><code>λx. (x (λx . λy . y) (λx . λy . x))</code> = <code>Lam(Branch(Branch(End, None), None), App( App( Var, Lam(None, Lam(Var, Var)) ), Lam(Var, Lam(None, Var)) )</code>
As opposed to De Brujin indices where the variables &quot;point&quot; to their corresponding lambda abstractions, with Bind Trees, the lambda terms carry an auxiliary datastructure specifying exactly which Variables should be replaced.</li>
</ul>
<p>In addition when it comes to storage and integration with Dither, these lambda expressions are identified by hash which gives a datastructure like this:</p>
<ul>
<li><code>Var</code></li>
<li><code>App(Hash, Hash)</code></li>
<li><code>Lam(Hash, Hash)</code></li>
</ul>
<h1 id="dither-application-index"><a class="header" href="#dither-application-index">Dither Application Index</a></h1>
<h2 id="list-of-application-ideas"><a class="header" href="#list-of-application-ideas">List of application Ideas</a></h2>
<ul>
<li><a href="applications/dither-chat.html">Dither Chat</a> - Community Chat application aiming to replace Discord. Provides e2ee encrypted DMs, voice chat, servers, voting, and integration with most other chat protocols.</li>
<li><a href="applications/dithca.html">Dithca</a> - Comprehensive &amp; Versatile decentralized comment system where anyone can comment on any type of data structure on Dither. Can interface with most other centralized comment systems and deal with misinformation &amp; crediting using a comprehensive community flagging system.
<ul>
<li>Can be used to create Reddit / Twitter Replacement. Can be integrated into other Dither applications or ported to web.</li>
</ul>
</li>
<li><a href="applications/dither-git.html">Dithgit</a> - Github on Dither</li>
<li><a href="applications/dithix.html">Dithix</a> - Dither Resource Manager: Manage and cache any kind of resource, interface between the Merkle Tree and the Filesystem.</li>
<li><a href="applications/nomia.html">Nomia on Dither</a> - Nomia on Dither, </li>
<li><a href="tree-of-math-old.html">Tree of Math</a> - Directed Acyclic Graph linking a standardized data structure for defintions and proofs together based on set theory creating a comprehensive tree of knowledge.</li>
<li><a href="applications/dither-coin.html">Dither Coin</a> - Cryptocurrency that solves all the current problems and creates a complete digital replication of cash (being decentralized, anonymous, non-volatile, and difficult to trace).</li>
<li><a href="applications/dither-dex.html">Dither DEX</a> - A all-faceted decentralized exchange to facilitate trade any kind of real or virtual asset. Supports meeting up in real life or exchanging other virtual assets anonymously and securely. Also supports moderation, karmic filtering</li>
<li><a href="applications/protocol-of-truth/protocol-of-truth.html">Protocol of Truth</a></li>
</ul>
<h2 id="other-application-ideas"><a class="header" href="#other-application-ideas">Other Application Ideas:</a></h2>
<ul>
<li>Manga &amp; Reading App
<ul>
<li>UI will be similar to <a href="https://github.com/tachiyomiorg/tachiyomi">Tachiyomi</a>, but will also support book reading. Pulls content from various websites and stores on Dither. Written in Flutter, desktop &amp; mobile versions. Supports comments through Dithca. Has built-in feature for paying for translation &amp; replacing bad translations with better translations if they are made.</li>
</ul>
</li>
<li>YouTube replacement
<ul>
<li>pulls and stores videos in a decentralized, uncensorable manner from any site that youtube-dl supports</li>
<li>Built-in chat (Using Dithca protocol)</li>
<li>Community-generated captions, sections, sponsor segments (pulled from sponsorblock) flagging etc.</li>
<li>Support for likes, view counting (and congregating), and &quot;Hearts&quot; (method of giving Dither Coin to creators).</li>
<li>Automatic community flagging of stolen/used content (including music, other people's videos, meme origins, pretty much anything)</li>
<li>Community misinformation flagging of content (interfaces with Dithca)</li>
</ul>
</li>
<li>Peer-to-Peer Exchange
<ul>
<li>Allow for the exchange</li>
</ul>
</li>
</ul>
<h1 id="application-design-philosophy"><a class="header" href="#application-design-philosophy">Application Design Philosophy</a></h1>
<p>Application APIs should be future-proofed as much as possible</p>
<p>Application GUIs should be generally be as cross platform as possible.</p>
<p>There should be different modes of use for different user skill levels to try and accomidate as many people as possible.</p>
<ul>
<li>These modes should enable/disable various aspects of <em>configurability</em> in the application</li>
<li><strong>Simple</strong> mode should be super easy to use for anyone and come with a quick tutorial
<ul>
<li>Configuration options should be assumed as much as possible, </li>
</ul>
</li>
<li><strong>Default</strong> mode should come with a tutorial and explain how modes work and how to change them</li>
<li><strong>Advanced</strong> mode assumes the user already knows how to use the app or can figure it out on their own. All configurability functionality should be enabled.
<ul>
<li>Application developers should strive to implement as much configurability as possible into every aspect of their application for complex users.</li>
<li>For desktop applications, configuration on a small level (for specific contextual buttons or features) could be shown through right-click menus.</li>
<li>For mobile applications these configuration items can be shown through a long-press.</li>
</ul>
</li>
</ul>
<h1 id="dither-chat"><a class="header" href="#dither-chat">Dither Chat</a></h1>
<ul>
<li><a href="applications/dither-chat.html#dither-chat">Dither Chat</a>
<ul>
<li><a href="applications/dither-chat.html#what-is-it">What is it</a></li>
<li><a href="applications/dither-chat.html#users--sync">Users &amp; Sync</a></li>
<li><a href="applications/dither-chat.html#chat-events">Chat Events</a></li>
<li><a href="applications/dither-chat.html#event-storage---storage-of-a-sequence-of-events-in-memory-or-storage">Event Storage - Storage of a sequence of events in memory or storage</a></li>
<li><a href="applications/dither-chat.html#trusted-friends-application-api">Trusted Friends Application API</a></li>
<li><a href="applications/dither-chat.html#chat-interface">Chat Interface</a></li>
<li><a href="applications/dither-chat.html#direct-messaging">Direct Messaging</a></li>
<li><a href="applications/dither-chat.html#group-messaging">Group messaging</a></li>
<li><a href="applications/dither-chat.html#servers">Servers</a>
<ul>
<li><a href="applications/dither-chat.html#roles-tags--colors">Roles, Tags &amp; Colors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="what-is-it-2"><a class="header" href="#what-is-it-2">What is it</a></h2>
<p>Dither Chat is a decentralized communication application using the Dither protocol. Servers are communally hosted with local consensus. Bots and plugins will be supported and also communally hosted.
tl;dr Discord but decentralized and better.</p>
<h2 id="users--sync"><a class="header" href="#users--sync">Users &amp; Sync</a></h2>
<ul>
<li>Each user may have multiple Peers (devices that Dither is installed on)</li>
<li>Chat Event history can be optionally synced across Peers.</li>
<li>A peer may host multiple users</li>
<li>Each UserId must have at least 1 peer that hosts it.</li>
</ul>
<h2 id="chat-events"><a class="header" href="#chat-events">Chat Events</a></h2>
<ul>
<li>All Events are signed with the private key of the person who sent it (these will be verified with a config option to let through or ignore unsigned or incorrectly signed events)</li>
<li>Chat Message structure
<ul>
<li>Date sent, last edited, markdown data / embed json, UserID mentions, emoji reactions</li>
</ul>
</li>
<li>Rich Presence (updating custom statuses and online/offline status)
<ul>
<li>Optional storage - can store presence update history (off by default)</li>
<li>Optional sending, extracts information about what you are currently doing and updates your friends. (on by default)</li>
<li>Customization options to only share with certain friends</li>
</ul>
</li>
</ul>
<h2 id="event-storage---storage-of-a-sequence-of-events-in-memory-or-storage"><a class="header" href="#event-storage---storage-of-a-sequence-of-events-in-memory-or-storage">Event Storage - Storage of a sequence of events in memory or storage</a></h2>
<ul>
<li>Stored as hash-linked local blocktree that messages are added to and new blocks are created when a certain amount of time elapses between the last message sent or max block size exceeded. Block size can be set to 1 to prevent messages being ordered out-of-order.</li>
<li>Indexing can be done on a by-block level (TODO: more customization options needed)</li>
<li>Block structure can allow for thread branching &amp; thread conversation movement across users. (e.g. create a group dm on top of an ongoing conversation)</li>
</ul>
<h2 id="trusted-friends-application-api"><a class="header" href="#trusted-friends-application-api">Trusted Friends Application API</a></h2>
<ul>
<li>Option to rank friends manually or by how much you chat with them</li>
<li>Can mark friends as “Trusted, Neutral or Untrusted”</li>
<li>Friend rank can be used by other applications</li>
<li>e.g. for Stellar Consensus Protocol quorum selection</li>
</ul>
<h2 id="chat-interface"><a class="header" href="#chat-interface">Chat Interface</a></h2>
<ul>
<li>Built-in markdown formatting + advanced chat box (similar to discord)</li>
<li>Link Displaying</li>
<li>Metadata can be sent so receiver doesn’t have to send request to web pages</li>
<li>TODO: Do we need to worry about invalid metadata being sent, tricking the user? Perhaps just scanning for suspicious domains is enough.</li>
<li>Receivers can choose if they want to fetch link data, only fetch commonly used sites (e.g. youtube, twitter, soundcloud etc.) or not fetch anything at all and only display sent link metadata</li>
</ul>
<h2 id="direct-messaging"><a class="header" href="#direct-messaging">Direct Messaging</a></h2>
<ul>
<li>Simply sending JSON-encoded message/other events to UserID on Dither</li>
</ul>
<h2 id="group-messaging"><a class="header" href="#group-messaging">Group messaging</a></h2>
<ul>
<li>Messages are broadcast over gossipsub and conflicting blocks are ordered by time.</li>
</ul>
<h2 id="servers"><a class="header" href="#servers">Servers</a></h2>
<ul>
<li>Servers are communially hosted by the moderator's computers. However, the owner has full control over the server and can choose who can assist</li>
<li>Red Nodes are hosting nodes, blue nodes are members. Blue node with yellow stroke is proxying it's connection to the server
<img src="applications/dither-chat/server-framework.svg" alt="Network Structure for Dither Server" />
Image of a possible dither-chat server arrangement</li>
</ul>
<h3 id="roles-tags--colors"><a class="header" href="#roles-tags--colors">Roles, Tags &amp; Colors</a></h3>
<ul>
<li>To distinguish people in a server, there are roles, name colors, and tags</li>
<li>Tags are shown next to tagowner's name as a small icon (like in Discord)
<ul>
<li>By default there is only 1 tag enabled for a server: the <em>Owner</em> tag.</li>
<li>There are other tag presets such as <em>Donator</em>, <em>Moderator</em> &amp; <em>Member</em></li>
<li>Custom tags can be created and be attached to a specific role.</li>
<li>Tags should be displayed in order of importance</li>
</ul>
</li>
<li>Roles can be made for anyone and can have permissions attached to them
<ul>
<li>Roles and can also be organized into hierarchies where users can be  ranked-up to posses a higher role (usually with more permissions)</li>
</ul>
</li>
<li>Each role has a color and color priority assigned
<ul>
<li>This is used to determine what color a user's username should be assigned</li>
</ul>
</li>
</ul>
<h1 id="dithca"><a class="header" href="#dithca">Dithca</a></h1>
<h2 id="a-comprehensive-commenting-system-built-on-top-of-dither"><a class="header" href="#a-comprehensive-commenting-system-built-on-top-of-dither">A comprehensive commenting system built on top of Dither</a></h2>
<p>Decentralized comment system adaptor.
Fully customizable comment system stored as a Dither Consensus Chain that can be created from any piece of data.
Uses Reddit's upvote/downvote system by default
Acts on its own or as a proxy overlay to various comment sites.</p>
<h2 id="comment-chain"><a class="header" href="#comment-chain">Comment Chain</a></h2>
<p>WIP: Figure out how dither consensus works</p>
<h3 id="comment-sort-methods"><a class="header" href="#comment-sort-methods">Comment Sort methods</a></h3>
<p>https://medium.com/hacking-and-gonzo/how-reddit-ranking-algorithms-work-ef111e33d0d9</p>
<h1 id="dithca-1"><a class="header" href="#dithca-1">Dithca</a></h1>
<h2 id="a-comprehensive-commenting-system-built-on-top-of-dither-1"><a class="header" href="#a-comprehensive-commenting-system-built-on-top-of-dither-1">A comprehensive commenting system built on top of Dither</a></h2>
<p>Decentralized comment system adaptor.
Fully customizable comment system stored as a Dither Consensus Chain that can be created from any piece of data.
Uses Reddit's upvote/downvote system by default
Acts on its own or as a proxy overlay to various comment sites.</p>
<h2 id="comment-chain-1"><a class="header" href="#comment-chain-1">Comment Chain</a></h2>
<p>WIP: Figure out how dither consensus works</p>
<h3 id="comment-sort-methods-1"><a class="header" href="#comment-sort-methods-1">Comment Sort methods</a></h3>
<p>https://medium.com/hacking-and-gonzo/how-reddit-ranking-algorithms-work-ef111e33d0d9</p>
<h1 id="protocol-of-truth"><a class="header" href="#protocol-of-truth">Protocol of Truth</a></h1>
<p>This is a protocol of back and forth debate with the aim to evaluate the quality and truthfulness of content posted to the internet.</p>
<p>If you have ever seen a photoshopped post on social media, or a video citing a badly done study, this techno-social protocol aims to inform through discourse the truthfulness of a given piece of media to anyone who might come across it.</p>
<p>The outcomes of this protocol label specific pieces of content. Here are some potential labels:</p>
<ul>
<li>Truthful - Unobjectionably true</li>
<li>False - Unobjectionably false
<ul>
<li>Benign - False, for comedy, or other reasons</li>
</ul>
</li>
<li>Factful - Well researched argument with generally accepted sources</li>
<li>Outdated - This might have been factful, but new information exists to provide alternative conclusions.</li>
<li>Opinionated - Content that is not sourced</li>
<li>Minority Opinion</li>
<li>Missing Context</li>
<li></li>
</ul>
<p>These labels are determined dynamically and are subject to change and dispution. The history of labels and the conversation around them are stored. Certain labels can only be applied on top of specific other labels.</p>
<p>New Objection
Undecided</p>
<p>Correct
Opinion</p>
<h2 id="ideas-1"><a class="header" href="#ideas-1">Ideas</a></h2>
<p>Idea: Instead of people upvoting and downvoting a given flag, they flag the flag and provide more supporting details. All this back and forth flagging results in a kind of &quot;tree of flags&quot; from which what is true, what is false, and what is ambiguous can be extracted.</p>
<p>Scene: Someone posts a video, there is an error in the video, someone posts a correction in the comment with a relevant tag. </p>
<h1 id="potential-examples-for-the-protocol-of-truth"><a class="header" href="#potential-examples-for-the-protocol-of-truth">Potential Examples for the Protocol of Truth</a></h1>
<p>To flesh out the idea and provide context of what this might look like, here are some real-world examples of videos that would be labeled under the protocol of truth.</p>
<h2 id="example-1-simple-factual-error"><a class="header" href="#example-1-simple-factual-error">Example 1: Simple Factual Error</a></h2>
<p>In Youtuber Fireship's video &quot;Rust in 100 Seconds&quot; at 0:55 he incorrectly says that mutable values are stored in the heap.</p>
<p>Ideal processes of correction:</p>
<ul>
<li>Someone realizes that there is an error and creates an <code>Objection</code>
<ul>
<li>Objections come with 3 parts: <code>Selection</code>, <code>Type</code>, <code>Reason</code>, and <code>Evidence</code> </li>
<li>For the <code>Selection</code>, they use the <code>Transcript</code> selection type and select the following lines:
<pre><code>00:55 mutable values or objects with an
00:57 unknown size at compile time are stored
00:59 in the heap memory
</code></pre>
</li>
<li>They set the <a href="applications/protocol-of-truth/./protocol-types.html"><code>Type</code></a> to <code>Error</code>.</li>
<li>For the <code>Reason</code> they say:</li>
<li>
<pre><code>&quot;While objects with unknown size at compile time are typically stored in the heap, mutable objects can be stored on the stack OR the heap.&quot;
</code></pre>
</li>
<li>They do not give any <code>Evidence</code> as this is common knowledge in rust.</li>
</ul>
</li>
<li>As people come to the video, they see the label on the video as <code>Pending - Potential Error</code> and click to see the <code>Objection</code> to do one of the following:
<ul>
<li>Mark the <code>Objection</code> as <code>True</code></li>
<li>Mark the <code>Objection</code> as <code>False</code></li>
<li>Flag the <code>Objection</code> as <code>Incomplete</code></li>
<li>Flag the <code>Objection</code> as <code>Unknown</code></li>
</ul>
</li>
<li>When flagging an Objection, you must have at least 10 karma and a verified human account. If you mark an objection as True while the statement is resolved as false or vice versa, you will loose 5 truth karma. If marked correctly you will gain 1 truth karma.</li>
<li>Confident people may also stake 100, 1000, or 10,000 karma to add 2, 3, or 4 votes respectively. (You will also loose half of your staked karma if you mark incorrectly, although you will gain more points if guessed correctly).</li>
<li>People may also stake their karma (max 10) on a resolution for increased karma return when the Objection comes to consensus in their favor. that they agree or that they are completely confident with the <code>Objection</code> (beause it is obvious). Or they comment under the objection with </li>
<li>If after a substantial period of time there is a 4/5th majority either way (True or False or Unknown), the objection will be marked true or false, which will change the label of the video. If there is no super consensus, it is marked as controversial. Controversial resolutions will only effect the video label for certain <code>Objection</code> types.</li>
<li>Ideally, the creator sees the <code>Objection</code> and the supporting &quot;True&quot; marks from the community, admits that they make an error and personally mark the <code>Objection</code> as True so that the community knows that the <code>Objection</code> has been acknowledged by the original creator.
<ul>
<li>In this case, Fireship could create a patch to that part of the video in response to the <code>Objection</code> and link to the original Objection to revert the &quot;small error&quot; label.</li>
</ul>
</li>
</ul>
<h1 id="dither-coin-ideas-are-work-in-progress"><a class="header" href="#dither-coin-ideas-are-work-in-progress">Dither Coin (Ideas are Work-In-Progress)</a></h1>
<p>Dither's built-in cryptocurrency aims to solve all existing problems with crypto:</p>
<ul>
<li>Scalability
<ul>
<li>Uses IOTA block structure combined with Federated Byzantine Voting for coordination.</li>
<li>Most users won't store the entire network history, just a slice of the current state relevent to performing transactions.</li>
</ul>
</li>
<li>Speed
<ul>
<li>Using Stellar Consensus Protocol and IOTA will be helpful to speed.</li>
<li>Bad Idea?: Also, there will be establishment of Zones in the network that have their own sub-exchanging separate from the rest of the network for fast local transactions. Usage of zones will be faster than sending transactions to the global network, however, for security purposes, zones must report transactions</li>
</ul>
</li>
<li>Anonymity
<ul>
<li>Will use zk-STARKS to obfuscate transaction amounts and sender</li>
</ul>
</li>
<li>Transaction Cost
<ul>
<li>Network is maintained by users, no mining necessary, therefore no fees will be required to transfer tokens.</li>
</ul>
</li>
<li>Volatility
<ul>
<li>There will be a system of provable currency deletion where you can create Dither Coins from thin air by proving that you send a certain amount of other support crypto coins to a public key with no corresponding private key (i.e. proving that they are inaccessable). The amount of coins created will be market exchange rate of the given coin into the U.S. dollar at the time of the transaction. (exchange rate is maintained by the network)</li>
<li><strong>This will ensure that the value of Dithercoin is tied to the US dollar.</strong></li>
</ul>
</li>
<li>Ease of Use
<ul>
<li>Dither Coin will be built-in to all aspects of Dither for tipping and other things</li>
<li>There will be SDKs so that Dither Coin can be built into other applications.</li>
</ul>
</li>
<li>Ease of Purchase
<ul>
<li>A system for peer-to-peer purchase of Dither Coin using other assets will be created using Dither Chain. (Idea WIP)</li>
</ul>
</li>
</ul>
<h1 id="the-d-framework"><a class="header" href="#the-d-framework">The D Framework</a></h1>
<p>The D framework is meant to be system for creating applications, documents, and any other kind of visual dynamic or static media. It is intended to replace the World Wide Web.</p>
<h3 id="what-is-the-essence-of-a-static-piece-of-content"><a class="header" href="#what-is-the-essence-of-a-static-piece-of-content">What is the essence of a static piece of content?</a></h3>
<p>A document, web page, or static site is kind of like a program with no inputs.</p>
<p>A pdf document typically contains all the things it needs to render a page to the user, but it doesn't contain the rendered data itself. It merely contains data used to render the page, such as text, fonts, images, formatting and so forth. For a static site, this data is in the form of HTML, CSS, and other linked data. Everything is fetched from the server and parsed into a viewable page. Unfortunately, HTML and CSS is not a particularly efficient format and not super generalized, meaning you are limited in the kinds of static experiences you can create. </p>
<h1 id="vision-for-the-future-of-dither"><a class="header" href="#vision-for-the-future-of-dither">Vision for the future of Dither</a></h1>
<p>This document outlines a vision for the mid-to-far term structure of Dither once the Disp programming language matures.</p>
<p>If you are looking for the current structure of Dither, check out the <a href="../dither.html#structure">Structure section</a> of the main Dither document.</p>
<h2 id="abandoning-the-file"><a class="header" href="#abandoning-the-file">Abandoning the &quot;File&quot;</a></h2>
<p>The file is the core of unix systems, but they have some issues.</p>
<h1 id="why-copyright-is-cancer"><a class="header" href="#why-copyright-is-cancer">Why Copyright is Cancer</a></h1>
<p>Copyright is ineffective in the internet age. Any piece of content can be pirated on a massive scale without the original creator even knowing. The only thing copyright does is suppress derivative creation on forums with strict copyright adherence. See these videos on why <a href="https://www.youtube.com/watch?v=1Jwo5qc78QU">the current copyright system is broken</a> and why it <a href="https://www.youtube.com/watch?v=QVkeJI2feyQ">makes no sense</a>. This document outlines an alternate system of funding creation that Dither aims to create.</p>
<p><strong>Have a decentralized &amp; democratized forum of communication and publication that no institution or individual can meaningfully obstruct.</strong> Dither is a protocol for creating decentralized applications.</p>
<p><strong>Provide a direct connection of support between the consumers and the creators allowing people to directly support creators for the content they produce</strong> (<a href="https://www.youtube.com/watch?v=mnnYCJNhw7w">Paying for Production, not Distribution</a>). Even huge projects like Marvel movies or video games can be supported through community fundraising. Each production raises the reputation of the artist(s), allowing them to raise more money from their fans for the next project.</p>
<p><strong>Preventing artists from having control over their art allows all artists to use and adapt and <em>recreate</em> the work of other artists</strong>. Imagine all the games and movies that were super hyped up but totally flopped. If anyone was allowed to make anyone else's work but better, artists have an incentive to make good stories so that they can raise money for their next project, instead of making something crappy and making all their money off of preorders. This would also prevent the fragmentation of distribution services as no one entity can have exclusive control over a piece of content.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
