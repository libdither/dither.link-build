<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dither Ideas</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="dither.html"><strong aria-hidden="true">1.</strong> Dither</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dither/structure.html"><strong aria-hidden="true">1.1.</strong> Structure</a></li><li class="chapter-item expanded "><a href="dither/routing/distance-based-routing.html"><strong aria-hidden="true">1.2.</strong> Distance-Based Routing</a></li><li class="chapter-item expanded "><a href="dither/routing/directional-trail-search.html"><strong aria-hidden="true">1.3.</strong> Directional Trail Search</a></li><li class="chapter-item expanded "><a href="dither/data/reverse-hash-lookup.html"><strong aria-hidden="true">1.4.</strong> Reverse Hash Lookup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> User Management - WIP</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.6.</strong> Consensus - WIP</div></li></ol></li><li class="chapter-item expanded "><a href="disp/disp.html"><strong aria-hidden="true">2.</strong> Disp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/universal-system-of-types.html"><strong aria-hidden="true">2.1.</strong> Universal System of Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/type-system.html"><strong aria-hidden="true">2.1.1.</strong> Standard Type System</a></li></ol></li><li class="chapter-item expanded "><a href="disp/syntax-agnosticism.html"><strong aria-hidden="true">2.2.</strong> Syntax Agnosticism</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/syntax.html"><strong aria-hidden="true">2.2.1.</strong> Standard Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="disp/names.html"><strong aria-hidden="true">2.3.</strong> Naming with Knowledge Graphs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Modular Parsing</div></li><li class="chapter-item expanded "><a href="disp/hardware-modeling.html"><strong aria-hidden="true">2.5.</strong> Hardware Modeling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.6.</strong> Self-Defined Types</div></li><li class="chapter-item expanded "><a href="disp/implementation.html"><strong aria-hidden="true">2.7.</strong> Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disp/bind-trees.html"><strong aria-hidden="true">2.7.1.</strong> Bind Trees</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="applications.html"><strong aria-hidden="true">3.</strong> Applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="applications/dither-chat.html"><strong aria-hidden="true">3.1.</strong> [WIP] Chat Client - Dither Chat</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Comment System - Dithca</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Package Manager - Dithix</div></li><li class="chapter-item expanded "><a href="applications/protocol-of-truth/protocol-of-truth.html"><strong aria-hidden="true">3.4.</strong> Protocol of Truth</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.1.</strong> Usage Examples (WIP)</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Browser Alternative - D Framework</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Philosophy</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="applications/application-design-philosophy.html"><strong aria-hidden="true">4.1.</strong> Design Philosophy</a></li><li class="chapter-item expanded "><a href="copyright-is-cancer.html"><strong aria-hidden="true">4.2.</strong> Copyright is Cancer</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Dither Ideas</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-dither-project"><a class="header" href="#the-dither-project">The Dither Project</a></h1>
<ul>
<li><a href="dither.html#the-dither-project">The Dither Project</a>
<ul>
<li><a href="dither.html#what-is-it">What is it?</a></li>
<li><a href="dither.html#a-plan-for-the-future-of-the-internet">A Plan for the Future of the Internet</a></li>
</ul>
</li>
<li><a href="dither.html#core-tenets">Core Tenets</a></li>
<li><a href="dither.html#structure">Structure</a>
<ul>
<li><a href="dither.html#core-process">Core Process</a></li>
<li><a href="dither.html#service-swarm">Service Swarm</a></li>
<li><a href="dither.html#user-interface">User Interface</a></li>
<li><a href="dither.html#interface-layer">Interface Layer</a></li>
</ul>
</li>
<li><a href="dither.html#other-links">Other Links</a>
<ul>
<li><a href="dither.html#inspirations-for-dither">Inspirations for Dither</a></li>
</ul>
</li>
</ul>
<h2 id="what-is-it"><a class="header" href="#what-is-it">What is it?</a></h2>
<p>Dither is a project with the goal of decentralizing the internet. It is a toolbox of various tools application developers can use to communicate privately, host data, manage accounts much more. It is currently being developed by <a href="https://github.com/zyansheep">@Zyansheep</a> and temporarily hosted via GitHub under the <a href="https://github.com/libdither">libdither</a> organization.</p>
<h2 id="a-plan-for-the-future-of-the-internet"><a class="header" href="#a-plan-for-the-future-of-the-internet">A Plan for the Future of the Internet</a></h2>
<p>The plan behind Dither is to create an modern internet unencumbered by any kind of central control. To accomplish this, Dither must somehow replace existing apps and services <em>by outcompeting them</em>. This is an incredibly monumental task, but there are some things that may help in Dither's favor.</p>
<ul>
<li><strong>No Hosting Costs</strong> — Being decentralized means the users host everything. If we can create a system to make it as painless as possible to host data, that would be ideal.</li>
<li><strong>Redesigning Everything is Sometimes Good</strong> — If applications using Dither are fundamentally better designed than the alternative and it is easy to switch, users will be more likely to use them.</li>
<li><strong>No Intellectual Property</strong> — Intellectual property protections do not apply to the core of Dither since it is a peer-to-peer network. This means that new platforms can be immediately populated with any existing content people might want to watch. Note: Precautions should be taken to make sure creators have a say in if they want their content to be shown on mainstream applications using the protocol to prevent public backlash.</li>
<li><strong>Standardization</strong> — Dither's ecosystem of APIs will all be compatible with each other which will infinitely improve the experience of the user. (Imagine being able to use a Discord-like chat room or a Reddit-like comment system underneath a YouTube video, or really any kind of system you want. It's all modular!).</li>
<li><strong>Natural Incentives</strong> — Similar to Brave browser's tipping system, If applications built on Dither have good incentive systems for content creation that extends to existing content, then creators whose content is uploaded to the network will automatically accrue income that will then be an incentive for them to claim their money and create an account. Unlike Brave, there won't be any KYC requirements :).</li>
</ul>
<p><em>The aim for Dither is to replace existing centralized applications with decentralized alternatives that are unified through their use of a singular, modular protocol.</em></p>
<p>See the <a href="applications.html">application document</a> for outlines of various applications that could be built using Dither.</p>
<h1 id="core-tenets"><a class="header" href="#core-tenets">Core Tenets</a></h1>
<p>It seems necessary for projects to have guidelines so that everyone may be on the same page. These are the ones I've chosen for now, as with everything, they are subject to change.</p>
<p><strong>Dither should be as modular as possible.</strong></p>
<ul>
<li>Reasoning: There should be no part of Dither that is difficult to replace with a different implementation and people should be able to pick and choose which parts they want.</li>
</ul>
<p><strong>Dither protocols, formats, and communities should be as interoperable as possible with existing protocols, formats, and communities</strong></p>
<ul>
<li>Reasoning: To grow Dither's userbase, It should be as easy as possible to transition to Dither from other services.</li>
<li>One example of this would be allowing someone to pull comments from Reddit / Youtube into <a href="applications/dithca.html">Dithca</a> and hosting them in a decentralized manner.</li>
<li>Another example might be <a href="applications/dithca.html">Dithca</a> storing Reddit credentials and being able to optionally interact with comment threads pulled from centralized websites.</li>
</ul>
<p><strong>Dither should rely on itself as much as possible for every aspect of development and usage.</strong></p>
<ul>
<li>Reasoning: It feels natural for a program to use itself if possible. Rust is written in itself, GitLabs is hosted using GitLabs, etc.</li>
<li>Code Versioning, Storage, Building, Distribution, and Social communication should all run through Dither applications if it won't compromise development too much.</li>
</ul>
<h1 id="structure"><a class="header" href="#structure">Structure</a></h1>
<p>Following the first tenet of Dither, in the future the lines between these layers will blur and everything will be a module. However, the design of current operating systems don't easily allow for shared code and data, requiring a more formal structure. In the future this layered structure will be replaced with a more <a href="dither/structure.html">flexible system</a>.</p>
<h2 id="core-process"><a class="header" href="#core-process">Core Process</a></h2>
<p>The Core Dither Process is the part that deals with all operating system-facing operations such as data storage, establishing peer-to-peer connections with other computers, in addition to managing all Dither services and connections between them.</p>
<p>This &quot;Core Process&quot; provides a few core APIs that only certain services running in the &quot;Service Swarm&quot; are allowed to use for security purposes. The idea behind a &quot;Core Process&quot; is to create a sandboxed environment for services to run in a safe manner.</p>
<p>peer-to-peer connections with other computers running Dither.
Currenly in the dither-sim program, this is implemented via a simple TCP stream. In the future this layer will be implemented using existing libraries such as <a href="https://libp2p.io/implementations/#transports">libp2p transports</a>, <a href="https://www.pluggabletransports.info/transports/">Pluggable Transports</a>, something else, or some amalgamation of all three. The idea behind this layer is to provide as many methods of communication as feasibly possible.</p>
<h2 id="service-swarm"><a class="header" href="#service-swarm">Service Swarm</a></h2>
<p>The service layer provides all functionality related to <a href="dither/routing/distance-based-routing.html">routing</a>, encryption, <a href="dither/routing/directional-trail-search.html">data storage</a>, <a href="dither/data/user-management.html">user management</a> and everything else. Each of these services are split up into separate modules each of which runs its own processes and communicates with other services through inter-process communication. </p>
<p>All these processes are managed as child processes under one &quot;main process&quot;. The main process contains the Transport Layer implementation, the routing protocol API and APIs for managing the child services as well as managing inter-process communication between child processes.</p>
<h2 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h2>
<p>The application layer contains services just like the service layer that are registered under the main process. These registered service's APIs can be used by other applications. </p>
<p>The application layer also refers to the application's core API, which is used by the interface layer. This &quot;core application API&quot; can be built into the applicaiton's executable, or it can run as a service under the main process and used by multiple interfaces. This is left up to the application developers. Applications with multiple interfaces should prefer to register application APIs under the main process.</p>
<p>Existing planned applications may be found <a href="applications.html">here</a>.</p>
<h2 id="interface-layer"><a class="header" href="#interface-layer">Interface Layer</a></h2>
<p>The final layer is the interface layer. This just refers to standalone applications that provide some kind of interface to the user using the services running under Dither.</p>
<p>These interfaces can be implemented however, but it is recommended for them to follow Dither's <a href="dither/application-design-philosophy.html">application design philosophy</a> for some level of standardization.</p>
<h1 id="other-links"><a class="header" href="#other-links">Other Links</a></h1>
<h3 id="a-hrefditherinspirationshtmlinspirations-for-dithera"><a class="header" href="#a-hrefditherinspirationshtmlinspirations-for-dithera"><a href="dither/inspirations.html">Inspirations for Dither</a></a></h3>
<p>Dither as with any creative endeavor takes inspiration from many other projects. This is a list of what parts of Dither have been inspired from other projects.</p>
<h1 id="structure-1"><a class="header" href="#structure-1">Structure</a></h1>
<p>This document outlines the major structure of Dither.</p>
<h2 id="system-manager"><a class="header" href="#system-manager">System Manager</a></h2>
<p>At the core of Dither is the system manager. This will be written in Rust and should only be run once on any given user account. The system manager provides a sandbox for Dither protocols and is built in a modular fashion to support any kind of setup or platform Dither might run on.</p>
<h3 id="core-services"><a class="header" href="#core-services">Core Services</a></h3>
<p>In order to sandbox Dither services, the system manager provides certain core services such as access to storage, network, or other Dither services.</p>
<ul>
<li>Service Manager
<ul>
<li>Provides any service with access the ability to organize other service's permissions, manage storage, as well as stop and start services at will.</li>
</ul>
</li>
<li>Network Service
<ul>
<li>Provides any service with access the ability to establish arbitrary TCP or UDP connections.</li>
</ul>
</li>
<li>Storage Service
<ul>
<li>Provides any service with access the ability to fetch and store data unique to that service.</li>
</ul>
</li>
</ul>
<p>Other services may be added as needed.</p>
<h3 id="service-swarm-1"><a class="header" href="#service-swarm-1">Service Swarm</a></h3>
<p>The system manager acts as a kind of sandbox for all services running on Dither and facilitates communication between different services.</p>
<h2 id="services"><a class="header" href="#services">Services</a></h2>
<p>This is a list of planned Dither services and their dependencies, note these may be split up into smaller sub-services.</p>
<ul>
<li>Distance-Based Routing, DBR (Network, Storage)</li>
<li>Directional-Trail Search, DTS (Distance-Based Routing, Storage)</li>
<li>Reverse-hash-lookup, RHL (Directional-Trail Search)</li>
<li>User Manager (DBR, DTS, RHL, Storage)</li>
<li>Dither Chat (DBR, DTS, RHL, User Manager, Storage)</li>
<li>Dithca (DTS, RHL, User Manager, Storage)</li>
<li>Protocol of Truth (DTS, RHL)</li>
</ul>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>Applications in Dither will be external programs that communicate with specific services in the Dither System Manager. 
i.e. 
Dither Chat will use the Dither Chat Service
Dithca will use the Dithca service.</p>
<p>Or applications can use a multitude of different services as needed.</p>
<h1 id="distance-based-routing"><a class="header" href="#distance-based-routing">Distance Based Routing</a></h1>
<p>Distance Based Routing (DBR) is a protocol for efficiently obfuscating connections between computers.</p>
<p>It improves on speed and flexibility over existing solutions (i.e. I2P and TOR) by taking into account the latency between nodes on the network. Instead of having to randomly choose nodes from a global list to route through, by knowing the relative latencies of nodes, routing paths between nodes can be chosen to optimize for low-latency or anonymity, or a balance of both.</p>
<p>Note: There is a <a href="https://www.dither.link/papers/distance-based-routing-whitepaper.pdf">research paper</a> comparing DBR to existing random-route solutions, for a somewhat amateurish comparison.</p>
<h2 id="the-main-idea"><a class="header" href="#the-main-idea">The Main Idea</a></h2>
<p>To figure out the relative latencies between nodes so as to establish low-latency paths to a destination, DBR makes the observation that the <strong>latency between nodes roughly correlates with the physical distance between them</strong>. This means coordinates can be assigned to nodes such that the communication latency between nodes can be estimated as the euclidian distance between coordinates. These coordinates will be referred to as &quot;routing coordinates&quot;.</p>
<p>While the goal of distancce-based routing could be achieved by assigning a routing coordinate to each node in the network, This has two major problems: </p>
<ol>
<li>
<p>Individual nodes or even whole parts of the network may be moving in relation to other parts of the network. (i.e. an airplane, or interplanetary communication). Thus requiring continuous recalculation of routing coordinates for all moving parties involved (which may include an entire planet, if used for inter-planetary routing).</p>
</li>
<li>
<p>Multiple networks may form independently and thus may have incompatible coordinate systems when communicating, requiring expansive re-syncronization or some kind of coordinate translation.</p>
</li>
</ol>
<p>The simple solution to this issue is to do what we humans do, <em>allow for different frames of reference</em>. Instead of each node calculating its own coordinates based on the coordinates of other nodes, each node is the center of its own universe and all other nodes are simply offset from itself. I will call these offsets &quot;relative routing coordinates&quot; (RRCs). When two nodes want to communicate with each other, they must figure out where they are relative to some shared frame of reference.</p>
<h2 id="peer-discovery"><a class="header" href="#peer-discovery">Peer Discovery</a></h2>
<p>To assign relative coordinates to nodes, there is a process of peer-discovery that functions as follows. This process happens whenever a new node joins the network.</p>
<ol>
<li>New node bootstraps onto the network by initiating connection to one or more existing nodes.</li>
<li>New node tests response times (latency) to connected nodes (peers). </li>
<li>New node requests from some subset of lowest-latency peers that it would like more peers.</li>
<li>New node's peers notify some slice of their peers that a new node would like more connections.</li>
<li>Notified nodes initiate connection with new node and new node measures latency to new peers.</li>
<li>New node takes note of the smallest latencies of its peers and goes back to step 3 until there are no closer nodes who want to peer.</li>
<li>After a certain number of closest nodes are found whose latency measurements are stable, the new node then calculates relative routing coordinates for all of its active peers via <a href="https://en.wikipedia.org/wiki/True-range_multilateration">multilateration</a> and broadcasts them to all the nodes used in the calculation.</li>
</ol>
<p>Through this process, a distributed small-world network is formed that reflects the physical topology of the relative orientations of the nodes.</p>
<h2 id="relative-routing-coordinates"><a class="header" href="#relative-routing-coordinates">Relative Routing Coordinates</a></h2>
<p>Relative Routing coordinates (RRC) in this system acts as a replacement for IP addresses in conventional routing.</p>
<h3 id="process"><a class="header" href="#process">Process</a></h3>
<p>A packet with an RRC can be routed to its destination via the following process:</p>
<ol>
<li>Node chooses the peer that will receive the packet next by comparing RRC directions</li>
<li>Node subtracts next peer's RRC from packet's RRC</li>
<li>Node forwards modified packet to next peer</li>
</ol>
<p>The process continues until the packet's RRC is all zeroes and the last node it reaches either is the destination node, knows the destination node, or is the wrong node in which case the packet is dropped or sent back depending on the packet type.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Compared to the global routing tables and complicated peering and address space allocation protocols that the existing internet uses. RRCs are much better for peer-to-peer applications because they are pretty much infinitely scalable. </p>
<p>That said, RRCs in some ways give away <em>more</em> information than traditional IP addresses do. Since the self-organized networks that use RRCs reflect real-world network topologies, just knowing someone's routing coordinate relative to you could be akin to knowing roughly where they live. This is an acceptable risk because it is much easier to do efficient onion routing on networks with RRCs than those without meaning that there is no reason not to have all connections onion-routed to some degree, providing better privacy overall.</p>
<p>Other benefits of routing coordinates are that they have the potential to almost completely prevent denial-of-service attacks. To even attempt such an attack, the attacker must find the routing coordinate of their target. Disregarding user error, this kind of attack is essentially impossible since everything is onion-routed by default. Even if the attacker does have the target's routing coordinate, trying to DOS a routing coordinate is like trying to DOS the entire expanse of network between the attacker and the target, the attacker(s) will be ineffective or blocked by other nodes automatically for overuse of the network. Even distributed denial of service attacks can be mitigated with additions to the protocol allowing the victim to notify the network that they are being attacked and to rate limit the attackers.</p>
<h2 id="anonymous-routing-onions-garlic-and-all-the-others"><a class="header" href="#anonymous-routing-onions-garlic-and-all-the-others">Anonymous Routing (Onions, Garlic, and all the others...)</a></h2>
<p>Conventionally, anonymous routing is an incredibly slow ordeal because of how intermediate peers are selected from the network. Due to this inefficiency, onion routing protocols have been somewhat limited in what kind of privacy they can provide because low data rates and high latency was a concern. This is no longer the case with DBR, which may support all kinds of anonymous routing schemes:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Onion_routing">Onion Routing</a>
<ul>
<li>The simplest routing of them all. Simply select a list of peers and establish a route from beginning to end.</li>
</ul>
</li>
<li>Garlic Routing
<ul>
<li>Similar to onion routing, but when sending packets to multiple peers at once, send them together for them to be split apart at some mid-point in the path.</li>
</ul>
</li>
<li>Multi-path routing
<ul>
<li>Maintain multiple Onion routes throughout the network and randomly send packets along all or some subset of them.</li>
</ul>
</li>
<li>Pool Routing
<ul>
<li>Create a group that nodes can join. All nodes randomly send randomly-sized data packets to all other nodes at random intervals, sending real data (padded) if there is data to send and sending random bytes if not.</li>
</ul>
</li>
</ul>
<p>DBR plans to use a modification of the <a href="https://arxiv.org/abs/1507.05724v3">HORNET</a> protocol for setting up fast onion-routed links.</p>
<h2 id="preventing-network-abuse"><a class="header" href="#preventing-network-abuse">Preventing Network Abuse</a></h2>
<p>Routing protocols that rely solely on people voluntarily hosting nodes typically only have a relatively small number of peers willing to route packets through themselves (i.e. TOR). This is why protocols like BitTorrent, I2P and IPFS have systems in place that incentivize peers who use the network to contribute back for the benefit of all.</p>
<p>To accomplish this behavior for DBR there must to be some way to limit packets going through nodes that either don't use the network that much or don't have a lot of bandwidth capacity and speed up packets through nodes that contribute greatly to the network. Also to take into consideration are the management of nodes that have inconsistent uptime or inconsistent routing.</p>
<p>When talking about incentives, we are talking about game theory. So lets analyze the game theoretical situation at the level of an individual node.</p>
<p>Constraints:</p>
<ul>
<li>Each node is directly connected to a fixed number of other nodes at a varying latencies and bandwidth.</li>
<li>Each node wants to send traffic through other nodes to use the network.</li>
<li>Each node wants to establish onion proxies with other nodes for privacy.</li>
<li>Each node has set of parameters that may change over time:
<ul>
<li>Percentage of the time it will immediately respond and route a packet.</li>
<li>Amount of traffic per unit time it is willing to route on average.</li>
<li>Max amount of traffic per unit time it can route.</li>
</ul>
</li>
</ul>
<p>The goal is to allow for unrelated nodes to route and establish proxies through each other in proportion to how much each node contributes in some way to the network.</p>
<p>Ideas:</p>
<ul>
<li>Each node keeps track of the amount of traffic (bytes) flowing through its itself from directly connected nodes.</li>
<li>Each node only sends traffic through direct nodes it knows it has received traffic from.</li>
<li>There is more to theorize about here for future research :)</li>
</ul>
<h2 id="inspirations--similar-work"><a class="header" href="#inspirations--similar-work">Inspirations / Similar Work</a></h2>
<p>(If anyone knows of any similar work not listed here, please tell me on Matrix!)</p>
<p>Vivaldi - <a href="https://pdos.csail.mit.edu/papers/vivaldi:sigcomm/paper.pdf">pdf</a>, <a href="https://www.youtube.com/watch?v=AszPoJjWK9Q&amp;t=1690s">video</a></p>
<p><a href="https://boonloo.cis.upenn.edu/papers/msherr-dissertation.pdf">Coordinate-Based Routing for High Performance Anonymity</a></p>
<h1 id="directional-trail-search"><a class="header" href="#directional-trail-search">Directional Trail Search</a></h1>
<p>Directional Trail Search (DTS) is a protocol for efficiently fetching a piece of stored data from a network given its hash.</p>
<p>It is intended to be a vast improvement over existing protocols like <a href="https://ipfs.tech/">IPFS</a> by removing the use of spatially-inefficient Distributed Hash Tables (DHT), allowing for anonymous retrival and optionally anonymous hosting, and fixing the issue of scalability to create a true &quot;inter-planetary&quot; file system.</p>
<h2 id="the-main-idea-1"><a class="header" href="#the-main-idea-1">The Main Idea</a></h2>
<p>DTS works via two forces: </p>
<ul>
<li>The desire of people (nodes) who want to host information and want their information to  be quickly accessible.</li>
<li>The desire of people (nodes) who want to access information and want to access it as fast as possible.</li>
</ul>
<p>These two forces are corralled by DTS to create an efficient system to host and find data. First let us talk about the desire of a node who wants to host some data. This desire manifests in the form of a &quot;data trail&quot;.</p>
<p>A data trail in DTS is a trail left in the network with the sole purpose of leading to a specific piece of data. Specifically, a trail is a chain of peered nodes that store a mapping between the hash of a specific piece of data, and the id of the next peer in the chain.</p>
<p>A data trail is formed with the following process:</p>
<ul>
<li>A node that wants to host information broadcasts a &quot;trail-laying&quot; packet that travels to a specific <a href="dither/routing/distance-based-routing.html">relative coordinate</a> on the network.</li>
<li>All the nodes that this &quot;trail-laying&quot; packet encounters on the way to its destination will do one of the following:
<ul>
<li>Reject to be a part of the trail, sending the packet to the previous node in the chain. This will reflect poorly on the node if it wants to host data of its own.</li>
<li>Register a connection between the hash contained within the packet and the id of the node the packet came from and forward the packet on to another node of a consistent distance away that it thinks will agree to be apart of the chain.</li>
</ul>
</li>
<li>Allowing nodes to either host data &amp; be apart of trails or not host data and not be apart of trails makes sure packets flow along computers that actually host data and are likely to be relatively stable and with resources to spare.</li>
</ul>
<p>Once a data trail is formed, it may be encountered by a &quot;trail-tracing&quot; packet which, once on the trail, is routed directly to the root of the trail.</p>
<p>However, this trail of nodes may be very thin, and thus trail-searching packets may have a hard time finding trail because they skip over too many nodes. To fix this issue, trail-laying packets will broadcast out to all known peers within a certain range that they are a part of a trail related to a specific hash. Peers receiving this broadcast will use a counting bloom filter to make a record that they are nearby a trail for a specific hash. &quot;trail-searching&quot; packets that come across these &quot;nearby-trail&quot; nodes can ask the nodes to ask all their peers within a certain radius if the peers are apart of a real trail. This casts a larger net and makes it easier to find trails without putting undue burden on too many nodes.</p>
<p>WIP: Section about the requesters role in the network and the expectations of the network for requesters to contribute to hosting for some time. (like bitorrent or ipfs)</p>
<h2 id="specific-structure-wip"><a class="header" href="#specific-structure-wip">Specific Structure (WIP)</a></h2>
<p><em>Note: This is an insanely hard problem to solve well: finding the node hosting a piece of data that matches a given hash on a network. The protocol here is a formulation of a protocol that might work to solve this problem.</em></p>
<p>Every Dither node implementing DTS contains the following state:</p>
<ul>
<li>A hashmap that maps multihashes to its corresponding data stored on disk, so that the node may retrieve its own data.
<ul>
<li>The size of this map should be primarily up to the node owner's discretion, depending on how much data they would like to store.</li>
<li>Data may be temporarily be added to this hashmap to help with the caching of other node's data.</li>
</ul>
</li>
<li>A hashmap that maps multihashes to peers.</li>
<li>A bloom filter containing a set of multihashes of which there are trails nearby.</li>
</ul>
<p>Every node will store the following information about their peers:</p>
<ul>
<li>WIP</li>
</ul>
<h2 id="downsides"><a class="header" href="#downsides">Downsides</a></h2>
<p>While Directional Trail Search is in theory much faster and much more efficient than DHTs, it is likely not as good when considering rare data. With a DHT, as long as there is at least one node hosting the data, it will be found eventually. With DTS, there is no guarantee that a piece of data will be found (i.e. if the data trails are too far away from the requesting node to be encountered by a searching packet).</p>
<p>There are multiple potential solutions in order of feasibility:</p>
<ul>
<li>Use a DHT in addition to DTS by default (this may have privacy implications)</li>
<li>Figure out how to get DTS to work better for rare files, perhaps by making it so that trails form circles around the earth and thus are nearly impossible not to encounter.</li>
<li>Store routing coordinates / routing areas on the Reverse Hash Lookup.</li>
<li>Implement a Network Coordination feature that tells all nodes in the network to notify a node when they find the requested data. (induces denial of service vector, probably a bad idea)</li>
</ul>
<h1 id="reverse-hash-lookup-wip"><a class="header" href="#reverse-hash-lookup-wip">Reverse Hash Lookup (WIP)</a></h1>
<p>Directed Acyclic Graph data structures (DAGs) may be elegant for storing and linking pieces of data, but they don't provide any kind of mutability on their own. This is the purpose of the Reverse Hash Lookup (RHL). RHL allows you to create a piece of data that links to two or more other pieces of data (via hash-linking) <em>and then lookup the link given one of the linked pieces of data</em>.</p>
<h2 id="structure-2"><a class="header" href="#structure-2">Structure</a></h2>
<p>RHL has many different ways to solve the two problems of distributing links and finding links. (Links here being pieces of data containing the hash of some other object that is being &quot;linked to&quot;). Links could be shared only with friends or trusted individuals, links could be broadcast all over the network and re-stored by other nodes, links could be stored in blockchains or link maps maintained by centralized servers, etc. All these different use-cases may be useful for different applications, so RHL tries to generalize over all possible use-cases.</p>
<p>Ideas:</p>
<ul>
<li>A Link defines its own methods of distribution and search. (Perhaps embedded as a hashtype).</li>
</ul>
<h3 id="methods-of-distribution--search"><a class="header" href="#methods-of-distribution--search">Methods of Distribution &amp; Search</a></h3>
<ul>
<li>A link can be broadcast to some set of trusted nodes (friend group), queries are done by asking friends if they have registered any links to an object.</li>
<li>A link can be registered in some sort of global consensus
<ul>
<li>Central server(s) store any links that are uploaded and respond to queries</li>
<li>Blockchain storing links (all &quot;full&quot; nodes store all links), queries done locally</li>
<li>Global Binary Tree mapping hashes to links (less space, more network activity when searching)</li>
</ul>
</li>
<li>A link can be broadcast via a publish-subscribe system and exist ephemerally, find beliefs by constantly listening on a topic (or to the entire network).</li>
</ul>
<h2 id="potential-applications"><a class="header" href="#potential-applications">Potential Applications</a></h2>
<p>This kinda of system is useful as a basis for other systems that need to link disparate pieces of data together for the purposes of querying or consensus. Here are just a few examples of the systems that RHL could enable:</p>
<ul>
<li><a href="dither/data/../../applications/dithca.html">Comment systems</a>. Each comment is a piece of data signed by some individual. Links can created over the comments that allow for querying some subset of all the comments, i.e. <code>top comments</code> or <code>set of all comments</code> or <code>comments from friends</code>. These links themselves may be immutable, but can be joined together via other links in a chain where the newest link in the chain is the most up-to-date view of the comment system.</li>
<li><a href="dither/data/../../applications/web-of-beliefs.html">Web of Beliefs</a>. A justification / rule links two beliefs together and beliefs may be private or publicly shared and distributed. Beliefs justified by some rule sets may be more propagated than others (i.e. scientific beliefs). Or beliefs can be accepted or rejected based on arbitrary social conditions like &quot;what proportion of my friends hold belief x?&quot; (Such as is the case with names). Multiple conflicting beliefs can be held at once, such as if it is not clear which one should be accepted as default (or there are uses for both beliefs in different context, such as with definitions).</li>
<li><a href="dither/data/zero-knowledge-proofs.html#example-trusted-user-distributed-anonymous-count">Anonymous Interactions</a>. Links could be generated ephemerally to prove that a public key in some trusted set of public keys interacted with a piece of content in some manner, and then added to some hyperloglog or statistical counter.</li>
</ul>
<h2 id="specification-ideas"><a class="header" href="#specification-ideas">Specification Ideas</a></h2>
<p>Disp type <code>Link&lt;Type&gt;</code> is implemented for whatever hash type is used in the specific link needed. i.e.</p>
<p>For a link to be type-valid, the objects it links to must also be the correct type. Zero-knowledge proofs could be used for this application in the future to avoid unnecessary fetching.</p>
<pre><code>struct Link&lt;T: Type&gt; {
  hash: Multihash,
  valid_link: (fetch(hash) : T)
}
</code></pre>
<h1 id="disp-decentralized-lisp"><a class="header" href="#disp-decentralized-lisp">Disp (Decentralized Lisp)</a></h1>
<p><em>What is a program? What is data? Why, they are one of the same.</em></p>
<p>Inspired by:</p>
<ul>
<li>Lisp for its flexibility</li>
<li>Idris &amp; Coq for the infinite expressiveness of dependent types</li>
<li>Rust for its speed</li>
<li>IPFS for deduplication</li>
</ul>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>A general outline of the (very lofty) goals of Disp.</p>
<ul>
<li>Most efficient language to run</li>
<li>Support for any cpu or interpreter</li>
<li>Most efficient language to write
<ul>
<li>Projectional Editing
<ul>
<li>Localization-agnostic naming</li>
</ul>
</li>
<li>Mixable syntax
<ul>
<li>Transpilation from any other language</li>
</ul>
</li>
</ul>
</li>
<li>Seamless integration into Dither</li>
</ul>
<h2 id="core-ideas"><a class="header" href="#core-ideas">Core Ideas</a></h2>
<ul>
<li><a href="disp/universal-system-of-types.html">Universal System of Types</a></li>
<li>[Binding Trees]</li>
</ul>
<h2 id="ideas"><a class="header" href="#ideas">Ideas</a></h2>
<ul>
<li>Objects are stored in self-defining data structures, i.e. they link to data that describes the format of the object (whether that be structurally, in-memory, or symbolically).
<ul>
<li>An object can be defined by its computation -&gt; Compilation can be as incremental as you want.</li>
<li></li>
</ul>
</li>
<li>High level programs are provably compiled into arbitrary lower-level representations with minimal programmer input.
<ul>
<li>An inductive datatype like <code>Nat</code> could be provably compiled into something like <code>BigInt</code> and be much more efficient. In tern, as long as you either ignore the possibility or proove it never happens, <code>BigInt</code> could be transformed into a  <code>U64</code> or something similar.</li>
</ul>
</li>
<li>Goal of compilation is cpu-specific object file complete with
<ul>
<li>data pre-loaded into memory</li>
<li>list of cpu-specific instructions.</li>
<li>hash of external virtual kernel API (i.e. syscall functions)</li>
</ul>
</li>
<li>virtual kernel APIs can be constrained to give programs access to different parts of the computer, or forgone entirely for programs that only manipulate data.</li>
<li>Running object files requires a uniquely setup syscall kernel API that can deal with interrupts</li>
</ul>
<h2 id="general-architecture"><a class="header" href="#general-architecture">General Architecture</a></h2>
<ul>
<li>
<p>There are two structures that are core to disp: <code>Expr</code>, and <code>Judgement</code>. <code>Expr</code> is an inductive structure that represents all the terms and types of the language. <code>Judgement</code> is the structure that matches <code>Expr</code>s together to create a typing judgement (i.e. saying some term is of some type or <code>a : A</code>). See [[expr]] for more details.</p>
</li>
<li>
<p>All structures of the language are defined through [[hashtypes]] </p>
</li>
<li>
<p>All language types are themselves self-defining structures, including the final bytecode file.</p>
</li>
<li>
<p>The language files are not stored as text files, they are instead stored as self-defining structures of groups of commands.</p>
</li>
</ul>
<h1 id="universal-system-of-types"><a class="header" href="#universal-system-of-types">Universal System of Types</a></h1>
<blockquote>
<p>a type system is a logical system comprising a set of rules that assigns a property called a type to every &quot;term&quot;</p>
</blockquote>
<p>Who choses the rules that assign types to terms? What makes one set of rules better than another? Some type systems are more general than others, some are more easily compiled into efficient bytecode, some allow for writing complex mathematical proofs. Exactly how large is this design space?</p>
<p>Disp captures the entire design space of possible type systems by generalizing the concept of types:</p>
<p><em>To make a long story short, a type is simply a program that returns true, false, or loops forever when given the source code of another program.</em></p>
<p>This allows the programmer to define their own type system in Disp. Or just use a pre-made one.</p>
<h2 id="the-implementation"><a class="header" href="#the-implementation">The Implementation</a></h2>
<p>In disp, every term is stored in a <a href="disp/names.html">context</a> as a judgement that contains a term and a type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Judgement {
	term: Expr,
	ty: Expr,
}
<span class="boring">}
</span></code></pre></pre>
<p>To verify if a judgement is valid and may be stored in a context, the compiler encodes the term using simple church-encoded data structures (like tuples and sums). The encoded form is then applied to the <code>ty</code> expression and beta-reduced. The judgement is considered valid if the expression reduces to <code>Expr::Var</code>.</p>
<h1 id="type-system-of-disp"><a class="header" href="#type-system-of-disp">Type System of Disp</a></h1>
<p>While the type system of Disp can be literally <a href="disp/universal-system-of-types.html">any computable program</a>, disp will have its own standard type system defined in the standard <a href="disp/names.html">context</a> that will allow for the creation of programs optimisable to a level at or beyond the speed of C and Rust.</p>
<p>The standard type system for disp should be:</p>
<ul>
<li>Simple
<ul>
<li>Relatively few core inference rules</li>
<li>More complex types are constructed from a few simple primitive type constructors.</li>
</ul>
</li>
<li>Fast
<ul>
<li>Types that reflect hardware primitives (such as machinecode) should be representable and the type system should be able to reason about equivalence between inefficient high-level types and efficient low-level types.</li>
</ul>
</li>
<li>Consistent
<ul>
<li>Logic of types should be consistent</li>
<li>Type checking should never loop indefinitely</li>
</ul>
</li>
<li>Representative
<ul>
<li>The standard type system for Disp aims to be a viable foundation for all of mathematics.</li>
</ul>
</li>
</ul>
<h2 id="substructural-types"><a class="header" href="#substructural-types">Substructural Types</a></h2>
<p>For a systems language, runtime overhead must be kept to a minimum. This means that the restrictions on lifetime and movability of heap and stack allocations should be modeled and enforced at compile time, instead of relying on a runtime methods such as garbage collection or reference counting.</p>
<p>Disp uses a type system that divides terms and types into 3 categories:</p>
<p>Unrestricted</p>
<ul>
<li>This includes most types, type constructors, and terms that can fit in a single CPU register.</li>
<li>Unrestricted objects may be moved around and duplicated at will in a program and don't require a specific function defining how they are deallocated.</li>
</ul>
<p>Linear</p>
<ul>
<li>This includes terms allocated on the heap, mostly structures with variable-length allocations.</li>
<li>Linear objects must be used in each context exactly once and must define at least one destructor or else it won't typecheck.</li>
<li>Linear objects may contain unrestricted objects, just like how heap-allocated objects may contain numbers that can be stored in registers.</li>
<li>Examples: ATS, Rust kinda</li>
</ul>
<p>Ordered</p>
<ul>
<li>This includes any term allocated on the stack, which is pretty much anything else.</li>
<li>Ordered objects must be used in each context exactly once and can only be used in reverse-order of allocation (like a stack).</li>
<li>Ordered objects may contain unrestricted or linear objects.</li>
<li>Examples: <a href="https://binji.github.io/posts/webassembly-type-checking/">Webassembly</a>, Porth</li>
</ul>
<p>A paper outlining a potential framework for a type system unifying all 3 of these substructural modes can be found <a href="https://mitpress-request.mit.edu/sites/default/files/titles/content/9780262162289_sch_0001.pdf">here</a>.</p>
<h2 id="minimal-type-theory"><a class="header" href="#minimal-type-theory">Minimal Type Theory</a></h2>
<p>In order for Disp to be able to double as a general-purpose theorem prover, the ideas from <a href="https://www.math.unipd.it/%7Esambin/txt/MaiettiSambin-rev2.pdf">this paper</a> describing a Minimal Type Theory (mTT) may be used.</p>
<h2 id="inspiration"><a class="header" href="#inspiration">Inspiration</a></h2>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=zt0OQb1DBko">ATS Language</a></p>
</li>
<li>
<p><a href="https://mitpress-request.mit.edu/sites/default/files/titles/content/9780262162289_sch_0001.pdf">Substructural Type Systems</a></p>
</li>
<li>
<p><a href="https://www.math.unipd.it/%7Esambin/txt/MaiettiSambin-rev2.pdf">Towards a Minimalist Foundation for Constructive Mathematics</a></p>
</li>
</ul>
<h1 id="syntax-agnosticism"><a class="header" href="#syntax-agnosticism">Syntax Agnosticism</a></h1>
<p>Syntax is one of the most visible barriers separating different languages from each other. It is easy to distinguish between Lisp and C, BASIC and APL, Haskell and Fortran. All these languages can pretty much do the same things, but their different syntax plays a big role in preventing programmers experienced in one from trying out another.</p>
<p>Disp aims to solve this issue by allowing the programmer to use whatever syntax style they prefer. This is possible because Disp is not stored in text files, it is instead temporarily rendered to a text file in a given syntax style and then parsed back to a structured binary format. Syntax styles should be compatible with each other and switching between them should be as simple as a click of a button.</p>
<h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>Since Disp has <a href="disp/syntax-agnosticism.html">Syntax Agnosticism</a>, it does not require one set syntax. For consistency and branding purposes however, Disp will have its own succinct and readable default syntax. This </p>
<p>Disp's default syntax is still a work-in-progress, however I think I want something similar to lisp with various Rust conventions sprinkled in.</p>
<h2 id="note-this-syntax-is-just-an-idea-and-subject-to-lots-of-change"><a class="header" href="#note-this-syntax-is-just-an-idea-and-subject-to-lots-of-change">Note: This Syntax is just an idea and subject to lots of change</a></h2>
<pre><code>// By itself, this is a comment
// It doubles as documentation when paired with an object

// This is an object, its type in inferred.
set Unit ();

// The function type is a function that takes two types A and B and returns a dependent product type where B is *not* dependent on a term of A.
set -&gt; λ[A B] Π[_:A] B
set /\ λ[A B] Π[C:Type] (A -&gt; B -&gt; C) -&gt; C
set id_type Π[A: Type] A -&gt; A
set id λ[t] λ[x] x : id_type

// Pair constructor
set pair_type Π[A: Type, B: Type] A -&gt; B -&gt; C
set pair λ[x y f] f x y

set Bool Π[A: Type] A -&gt; A -&gt; A {
	true: λ[x y] x
	false: λ[x y] y
}







</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code>// This is a comment, it also doubles as documentation

// Variables
(set ten 10:b64)

// variable names can have most symbols in them
(set ten? 10) // literal 10 resolves to 10:bsize

(use std::flow::assert)
(assert_exact ten ten?) // =&gt; true only on 64-bit systems, because bsize = b64
(assert_eq ten ten?) // =&gt; always true

// Reason about functions
(use std::code::compile)
(assert_exact
	// Parentheses implied
	compile `(a b) `(assert_eq a b) 
	compile `(a b) `(panic_if (!= a b))
	compile `(a b) `(if (= a b) (panic))
) // =&gt; these functions are the exact same when compiled

// Strings
(set string &quot;Hello, World!&quot;) // implies &quot;Hello, World!&quot;:String

// String declaration follows the same declaration convention as Rust, except that Strings are stack-allocated by default.
(print string) // =&gt; prints out &quot;Hello, World!&quot;
(print &quot;And the God of Programming said: {:?}&quot; string) // =&gt; prints out formatted string with debug representation of string.

// Type definition (with type macro)
(type SomeStruct
	number b64
	_ (String Character)
)

// This macro resolves to something similar to using the formats of Type and TypeLocalization hashtype.
(set SomeStruct ( (hash b64) ( (hash String) (hash Character)):Type))
(set SomeStructLocalization ((hash SomeStruct) ):TypeLocalization)

// Trait definition using trait macro
// A trait defines a collection of adjacent data (either a function, or a value) that is attached to a Type
(trait SomeTrait
	fn size (&amp;self) (usize)
)

(impl AddOne SomeStruct
	set add_one (fn (~self) (self) (
		(inc (loc self number) 1)
		(self)
	))
)

// Initiate SomeStruct with values
// symbol = thing notation is equivalent to (set symbol thing)
some_struct = (1098342 (&quot;Hello, World!&quot;, 'u')):SomeStruct

(some_struct size)

(1098342:B64 -12304: String:&quot;hello there&quot; Symbol:hello)
</code></pre>
<h1 id="names"><a class="header" href="#names">Names</a></h1>
<h2 id="a-natural-idea"><a class="header" href="#a-natural-idea">A Natural Idea</a></h2>
<p>A word in a language is a label to which we assign a definition. These definitions may be physical or abstract, but in a programming languages: a definition is a piece of code.</p>
<p><code>let id = λx . x</code> - We are fitting the label &quot;id&quot; to the definition <code>λx . x</code></p>
<p>Words in natural languages may have more than one definition. When using these words in conversation however, typically only one definition is intended by the speaker. The definitions and names we use in conversation are set by the <em>context</em> of the conversation to which the speaker hopes the listener has deduced correctly. </p>
<p>Contexts also exist in programming languages. Namespaces, modules, classes. Unlike real conversation where contexts can be deduced from various cues, computers need to know exactly what definition a label corresponds to and can't just &quot;figure it out&quot; (yet). A context in a programming language is meticulously organized hierarchy of modules. When using these modules, programmers have to specifically import names into the context of their code, requiring the programmer to keep in their head where in the module hierarchy all the names they need to use are.</p>
<p>Contrast this to how we deal with context in natural languages, where when starting a conversation, we assume don't assume what the single definition of a given word will be without first inferring a context from surrounding cues. For example if we are talking garnishing food, you might be referring to adding things whereas if we are talking about garnishing wages, we are talking about taking away. This is the way our brains are used to dealing with context, so it puts a special strain on the programmer where a complex pre-defined hierarchy must be memorized to actually program effectively.</p>
<p>The goal: Remove this burden on the programmer by resolving names from the context of the program.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A perfect way to model resolving from contexts is to use a <a href="https://en.wikipedia.org/wiki/Knowledge_graph">knowledge graph</a>. A name may resolve to many different expressions, but the scope of possibilities may be restricted further by the context of the types of surrounding types or specifically declared contexts.</p>
<h1 id="structure-3"><a class="header" href="#structure-3">Structure</a></h1>
<p>Names and programs in Disp are separate, this is so that alpha-equivalence is preserved and so that the same program may be able to named differently by different people.</p>
<p>A program is represented by an <a href="disp/expr.html"><code>Expr</code></a>. A Named program is represented by a <code>NamedExpr</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Expr {
	Abs { binding: Binding, expr: Expr },
	App { func: Expr, args: Expr }
	Var,
}
struct NamedExpr {
	name: String,
	expr: NameTree,
}
enum NameTree {
	Abs { bind_name: String, expr: NameTree }, // For Abs and Pi binding
	App { left: NameTree, right: NameTree } // For App
	Name(NamedExpr)
	End,
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="hardware-modeling"><a class="header" href="#hardware-modeling">Hardware Modeling</a></h1>
<h4 id="how-do-we-generate-fast-code"><a class="header" href="#how-do-we-generate-fast-code">How do we generate fast code?</a></h4>
<ul>
<li>Currently, Optimizing Compilers generate fast code through intermediate representations and various techniques to figure out what code is needed and what code is not.
<ul>
<li>https://www.lihaoyi.com/post/HowanOptimizingCompilerWorks.html</li>
</ul>
</li>
<li>These strategies are mostly arbitrary and not easily improvable. A programmer has to go through and figure out which optimizations are worth the compiler computation cost and which aren't. There are an immeasurable number of trade-offs and potential improvements for a given piece of hardware. This calls for a new method to quantify these trade-offs and create a better system.</li>
</ul>
<h4 id="how-do-we-create-fast-algorithms"><a class="header" href="#how-do-we-create-fast-algorithms">How do we create fast algorithms?</a></h4>
<ul>
<li>We typically manually write algorithms we think will run fast and then compare them to other algorithms using benchmarks. However, benchmarks have so many confounding factors that it is difficult to compare two of them and make definitive conclusions.
<ul>
<li>Results may also depend on whether the algorithm is fit for the CPU architecture. The same algorithm may run faster or slower depending on a bazillion different factors such as <a href="https://www.youtube.com/watch?v=r-TLSBdHe1A">layout</a></li>
</ul>
</li>
</ul>
<h2 id="how-to-model-performance"><a class="header" href="#how-to-model-performance">How To Model Performance</a></h2>
<p>To create efficient code, we must have a model of how that code is run. Typically this model is held in the programmer's mind and is expressed through compiler and algorithm design. Instead of holding it in our forgetful, biased brains, it might be a good idea to have a software-defined model of our hardware so that we can prove that our optimizations and algorithms are actually faster.</p>
<p>Model specifications &amp; options</p>
<ul>
<li>Should take into account modern CPU features such as: pipelining, superscalar execution, out-of-order execution, and branch prediction.</li>
<li>Should be generic enough to model different CPU generations of the same architecture.</li>
<li>Should take into account other hardware qualities such as RAM latency, GPU parallelization options, and any other model-able aspect that could influence performance.</li>
<li>Simple models could be hand-crafted using published characteristics from documents like the <a href="https://www.agner.org/optimize/#manual_instr_tab">Instruction Tables</a></li>
<li>More sophisticated models could be made for open source CPU architectures by using the logic gate layout of the CPU. (This may be possible for architectures like RISC-V)</li>
</ul>
<p>Benefits to this approach include:</p>
<ul>
<li><strong>No more annoying benchmarks</strong> Faster algorithms can be provably faster for a given model.
<ul>
<li>Note: Benchmarks still need to be used to compare different models of a hardware system, however these benchmarks can be much more sophisticated and take into account more confounding factors.</li>
</ul>
</li>
<li><strong>Faster optimization adoption</strong> Compilers can substitute old optimizations for faster ones without delay using a public distributed database of optimization.
<ul>
<li>Scenario
<ul>
<li>Bob has a new optimization for a certain pattern of functional expressions.</li>
<li>Bob proves it is faster for a well-trusted model of x86_64 CPUs</li>
<li>Bob broadcasts optimization to everyone</li>
<li>Everyone checks the proof that it is faster</li>
<li>Everyone uses new optimization, programs are faster</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="fundamental-constructs"><a class="header" href="#fundamental-constructs">Fundamental Constructs</a></h1>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<p>Expressions in Disp are programs and match the untyped lambda calculus. They are represented as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Expr {
	Var,
	Lam { bind: Binding, expr: Expr },
	App { func: Expr, func: Expr },
}
enum Binding {
	None,
	End,
	Branch(Binding, Binding),
}
<span class="boring">}
</span></code></pre></pre>
<p>See how the <code>Binding</code> structure works <a href="disp/./bind-trees.html">here</a>.</p>
<h2 id="judgements"><a class="header" href="#judgements">Judgements</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Judgement {
	term: Expr,
	ty: Expr,
}
<span class="boring">}
</span></code></pre></pre>
<p>Judgements are considered valid if when the structure of <code>term</code> is encoded into the lambda calculus, and <code>Expr::App(ty, encoding)</code> beta-reduces to <code>Expr::Var</code>.</p>
<h2 id="contexts"><a class="header" href="#contexts">Contexts</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context {
	names: Map&lt;String, Judgement&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="bind-trees-a-deduplication-friendly-alternative-to-de-brujin-indicies"><a class="header" href="#bind-trees-a-deduplication-friendly-alternative-to-de-brujin-indicies">Bind Trees: A deduplication friendly alternative to De Brujin Indicies.</a></h1>
<p>Used in [Disp]</p>
<p>The current most well known way of representing the lambda calculus is <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Brujin Indicies</a>.</p>
<p>This is where you have 3 variants of a term:</p>
<ul>
<li><code>Var(Number)</code> - Number represents how many layers of abstraction (lambdas) the variable is away from its intended binding</li>
<li><code>App(Term, ...)</code> - Application is a list of Terms</li>
<li><code>Lam(Term)</code> - Lambda represents an abstraction point</li>
</ul>
<p>An example of what this might look like for common equations:</p>
<ul>
<li><code>λx . x</code> = <code>Lam(Var(1))</code></li>
<li><code>λx. λy. x</code> = <code>Lam(Lam(Var(2)))</code></li>
<li><code>λx. (x (λx . λy . x) (λx . λy . y))</code> = <code>Lam(App(Var(1), Lam(Lam(Var(1))), Lam(Lam(Var(2)))))</code></li>
</ul>
<p>For Disp, I have devised an alternative method that doesn't require integers (and thus is not limited by encoding constraints)</p>
<p>Disp has the same 3 variants of Term:</p>
<ul>
<li><code>Var</code></li>
<li><code>App(Term, Term)</code></li>
<li><code>Lam(Binding, Term)</code></li>
</ul>
<p>In addition to a construct Binding:</p>
<ul>
<li><code>None</code></li>
<li><code>End</code></li>
<li><code>Branch(Binding, Binding)</code></li>
</ul>
<p>In fact, the Binding datastructure can be repurposed from the Term datastructure.
<code>(End = Var, None = Lam(Var, Var), Branch(Binding, Binding) = App(Term, Term))</code></p>
<p>Common equation examples of this structure might look like:</p>
<ul>
<li><code>λx . x</code> = <code>Lam(Var, Var)</code></li>
<li><code>λx. λy. x</code> = <code>Lam(Var, Lam(None, Var))</code></li>
<li><code>λx. (x (λx . λy . y) (λx . λy . x))</code> = <code>Lam(Branch(Branch(End, None), None), App( App( Var, Lam(None, Lam(Var, Var)) ), Lam(Var, Lam(None, Var)) )</code>
As opposed to De Brujin indices where the variables &quot;point&quot; to their corresponding lambda abstractions, with Bind Trees, the lambda terms carry an auxiliary datastructure specifying exactly which Variables should be replaced.</li>
</ul>
<p>In addition when it comes to storage and integration with Dither, these lambda expressions are identified by hash which gives a datastructure like this:</p>
<ul>
<li><code>Var</code></li>
<li><code>App(Hash, Hash)</code></li>
<li><code>Lam(Hash, Hash)</code></li>
</ul>
<h1 id="dither-application-index"><a class="header" href="#dither-application-index">Dither Application Index</a></h1>
<h2 id="list-of-application-ideas"><a class="header" href="#list-of-application-ideas">List of application Ideas</a></h2>
<ul>
<li><a href="applications/dither-chat.html">Dither Chat</a> - Community Chat application aiming to replace Discord. Provides e2ee encrypted DMs, voice chat, servers, voting, and integration with most other chat protocols.</li>
<li><a href="applications/dithca.html">Dithca</a> - Comprehensive &amp; Versatile decentralized comment system where anyone can comment on any type of data structure on Dither. Can interface with most other centralized comment systems and deal with misinformation &amp; crediting using a comprehensive community flagging system.
<ul>
<li>Can be used to create Reddit / Twitter Replacement. Can be integrated into other Dither applications or ported to web.</li>
</ul>
</li>
<li><a href="applications/dither-git.html">Dithgit</a> - Github on Dither</li>
<li><a href="applications/dithix.html">Dithix</a> - Dither Resource Manager: Manage and cache any kind of resource, interface between the Merkle Tree and the Filesystem.</li>
<li><a href="applications/nomia.html">Nomia on Dither</a> - Nomia on Dither, </li>
<li><a href="tree-of-math-old.html">Tree of Math</a> - Directed Acyclic Graph linking a standardized data structure for defintions and proofs together based on set theory creating a comprehensive tree of knowledge.</li>
<li><a href="applications/dither-coin.html">Dither Coin</a> - Cryptocurrency that solves all the current problems and creates a complete digital replication of cash (being decentralized, anonymous, non-volatile, and difficult to trace).</li>
<li><a href="applications/dither-dex.html">Dither DEX</a> - A all-faceted decentralized exchange to facilitate trade any kind of real or virtual asset. Supports meeting up in real life or exchanging other virtual assets anonymously and securely. Also supports moderation, karmic filtering</li>
<li><a href="applications/protocol-of-truth/protocol-of-truth.html">Protocol of Truth</a></li>
</ul>
<h2 id="other-application-ideas"><a class="header" href="#other-application-ideas">Other Application Ideas:</a></h2>
<ul>
<li>Manga &amp; Reading App
<ul>
<li>UI will be similar to <a href="https://github.com/tachiyomiorg/tachiyomi">Tachiyomi</a>, but will also support book reading. Pulls content from various websites and stores on Dither. Written in Flutter, desktop &amp; mobile versions. Supports comments through Dithca. Has built-in feature for paying for translation &amp; replacing bad translations with better translations if they are made.</li>
</ul>
</li>
<li>YouTube replacement
<ul>
<li>pulls and stores videos in a decentralized, uncensorable manner from any site that youtube-dl supports</li>
<li>Built-in chat (Using Dithca protocol)</li>
<li>Community-generated captions, sections, sponsor segments (pulled from sponsorblock) flagging etc.</li>
<li>Support for likes, view counting (and congregating), and &quot;Hearts&quot; (method of giving Dither Coin to creators).</li>
<li>Automatic community flagging of stolen/used content (including music, other people's videos, meme origins, pretty much anything)</li>
<li>Community misinformation flagging of content (interfaces with Dithca)</li>
</ul>
</li>
<li>Peer-to-Peer Exchange
<ul>
<li>Allow for the exchange</li>
</ul>
</li>
</ul>
<h1 id="dither-chat"><a class="header" href="#dither-chat">Dither Chat</a></h1>
<ul>
<li><a href="applications/dither-chat.html#dither-chat">Dither Chat</a>
<ul>
<li><a href="applications/dither-chat.html#what-is-it">What is it</a></li>
<li><a href="applications/dither-chat.html#users--sync">Users &amp; Sync</a></li>
<li><a href="applications/dither-chat.html#chat-events">Chat Events</a></li>
<li><a href="applications/dither-chat.html#event-storage---storage-of-a-sequence-of-events-in-memory-or-storage">Event Storage - Storage of a sequence of events in memory or storage</a></li>
<li><a href="applications/dither-chat.html#trusted-friends-application-api">Trusted Friends Application API</a></li>
<li><a href="applications/dither-chat.html#chat-interface">Chat Interface</a></li>
<li><a href="applications/dither-chat.html#direct-messaging">Direct Messaging</a></li>
<li><a href="applications/dither-chat.html#group-messaging">Group messaging</a></li>
<li><a href="applications/dither-chat.html#servers">Servers</a>
<ul>
<li><a href="applications/dither-chat.html#roles-tags--colors">Roles, Tags &amp; Colors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="what-is-it-1"><a class="header" href="#what-is-it-1">What is it</a></h2>
<p>Dither Chat is a decentralized communication application using the Dither protocol. Servers are communally hosted with local consensus. Bots and plugins will be supported and also communally hosted.
tl;dr Discord but decentralized and better.</p>
<h2 id="users--sync"><a class="header" href="#users--sync">Users &amp; Sync</a></h2>
<ul>
<li>Each user may have multiple Peers (devices that Dither is installed on)</li>
<li>Chat Event history can be optionally synced across Peers.</li>
<li>A peer may host multiple users</li>
<li>Each UserId must have at least 1 peer that hosts it.</li>
</ul>
<h2 id="chat-events"><a class="header" href="#chat-events">Chat Events</a></h2>
<ul>
<li>All Events are signed with the private key of the person who sent it (these will be verified with a config option to let through or ignore unsigned or incorrectly signed events)</li>
<li>Chat Message structure
<ul>
<li>Date sent, last edited, markdown data / embed json, UserID mentions, emoji reactions</li>
</ul>
</li>
<li>Rich Presence (updating custom statuses and online/offline status)
<ul>
<li>Optional storage - can store presence update history (off by default)</li>
<li>Optional sending, extracts information about what you are currently doing and updates your friends. (on by default)</li>
<li>Customization options to only share with certain friends</li>
</ul>
</li>
</ul>
<h2 id="event-storage---storage-of-a-sequence-of-events-in-memory-or-storage"><a class="header" href="#event-storage---storage-of-a-sequence-of-events-in-memory-or-storage">Event Storage - Storage of a sequence of events in memory or storage</a></h2>
<ul>
<li>Stored as hash-linked local blocktree that messages are added to and new blocks are created when a certain amount of time elapses between the last message sent or max block size exceeded. Block size can be set to 1 to prevent messages being ordered out-of-order.</li>
<li>Indexing can be done on a by-block level (TODO: more customization options needed)</li>
<li>Block structure can allow for thread branching &amp; thread conversation movement across users. (e.g. create a group dm on top of an ongoing conversation)</li>
</ul>
<h2 id="trusted-friends-application-api"><a class="header" href="#trusted-friends-application-api">Trusted Friends Application API</a></h2>
<ul>
<li>Option to rank friends manually or by how much you chat with them</li>
<li>Can mark friends as “Trusted, Neutral or Untrusted”</li>
<li>Friend rank can be used by other applications</li>
<li>e.g. for Stellar Consensus Protocol quorum selection</li>
</ul>
<h2 id="chat-interface"><a class="header" href="#chat-interface">Chat Interface</a></h2>
<ul>
<li>Built-in markdown formatting + advanced chat box (similar to discord)</li>
<li>Link Displaying</li>
<li>Metadata can be sent so receiver doesn’t have to send request to web pages</li>
<li>TODO: Do we need to worry about invalid metadata being sent, tricking the user? Perhaps just scanning for suspicious domains is enough.</li>
<li>Receivers can choose if they want to fetch link data, only fetch commonly used sites (e.g. youtube, twitter, soundcloud etc.) or not fetch anything at all and only display sent link metadata</li>
</ul>
<h2 id="direct-messaging"><a class="header" href="#direct-messaging">Direct Messaging</a></h2>
<ul>
<li>Simply sending JSON-encoded message/other events to UserID on Dither</li>
</ul>
<h2 id="group-messaging"><a class="header" href="#group-messaging">Group messaging</a></h2>
<ul>
<li>Messages are broadcast over gossipsub and conflicting blocks are ordered by time.</li>
</ul>
<h2 id="servers"><a class="header" href="#servers">Servers</a></h2>
<ul>
<li>Servers are communially hosted by the moderator's computers. However, the owner has full control over the server and can choose who can assist</li>
<li>Red Nodes are hosting nodes, blue nodes are members. Blue node with yellow stroke is proxying it's connection to the server
<img src="applications/dither-chat/server-framework.svg" alt="Network Structure for Dither Server" />
Image of a possible dither-chat server arrangement</li>
</ul>
<h3 id="roles-tags--colors"><a class="header" href="#roles-tags--colors">Roles, Tags &amp; Colors</a></h3>
<ul>
<li>To distinguish people in a server, there are roles, name colors, and tags</li>
<li>Tags are shown next to tagowner's name as a small icon (like in Discord)
<ul>
<li>By default there is only 1 tag enabled for a server: the <em>Owner</em> tag.</li>
<li>There are other tag presets such as <em>Donator</em>, <em>Moderator</em> &amp; <em>Member</em></li>
<li>Custom tags can be created and be attached to a specific role.</li>
<li>Tags should be displayed in order of importance</li>
</ul>
</li>
<li>Roles can be made for anyone and can have permissions attached to them
<ul>
<li>Roles and can also be organized into hierarchies where users can be  ranked-up to posses a higher role (usually with more permissions)</li>
</ul>
</li>
<li>Each role has a color and color priority assigned
<ul>
<li>This is used to determine what color a user's username should be assigned</li>
</ul>
</li>
</ul>
<h1 id="protocol-of-truth"><a class="header" href="#protocol-of-truth">Protocol of Truth</a></h1>
<p>This is a protocol of back and forth debate with the aim to evaluate the quality and truthfulness of content posted to the internet.</p>
<p>If you have ever seen a photoshopped post on social media, or a video citing a badly done study you will know that it is incredibly hard to figure out how well-researched a piece of content is at first glance. This Dither protocol aims to inform through discourse the truthfulness of a given piece of media to anyone who might come across it.</p>
<h3 id="the-process"><a class="header" href="#the-process">The Process</a></h3>
<p>The process for the Protocol of Truth is carried out by trusted individuals (chosen by a karma system). The steps are as follows:</p>
<ol>
<li>The Media is examined for a set of assertions it makes as well as deductive and inductive reasoning made using the assertions. This creates a &quot;Assertion Graph&quot;.</li>
<li>Once the graph is constructed and properly cited (i.e. each assertion should provide some link to the part of the media it was extracted from) assertions may be supported or criticized.</li>
<li>Assertions in &quot;Assertion Graphs&quot; may be shared between different media and thus the supporting evidence presented by one media may be used in the justification of another. This supporting evidence may be found independently or through the author's cited sources.</li>
<li>Each Assertion in the graph may be labeled through a persistent voting scheme under the following categories of deduction type, truthfulness and standard of evidence.</li>
</ol>
<ul>
<li><strong>Deductive / Inductive</strong> - What kind of assertion is it.</li>
<li><strong>Truthiness</strong> - How the trusted community rates the assertion in terms of truthfulness.
<ul>
<li>Inherited - The assertion is deduced from the assumptions, therefore its truthfulness is inherited from the truthfulness of the assumptions.</li>
<li>Likely True - The assertion is likely true</li>
<li>Likely False - The assertion is likely false</li>
<li>Ambiguous - The truth of the assertion cannot be satisfyingly asserted either way.</li>
</ul>
</li>
<li><strong>Standard of Evidence</strong>
<ul>
<li>Statistically Significant - The assertion is supported by sound scientific observation or experiment.</li>
<li>Personal Experience - The assertion is a personal observation, it is subject to individual bias.</li>
<li>Common Knowledge - The assertion is generally held to be true, but there is no specific evidence to support it. i.e. stuff like &quot;thing X exists&quot; or &quot;hammers are generally used to hammer in nails&quot;. There is no hard evidence for it, but it is generally held to be true. This is the least powerful standard of evidence and should be replaced with a more powerful form if at all possible.</li>
</ul>
</li>
</ul>
<h1 id="application-design-philosophy"><a class="header" href="#application-design-philosophy">Application Design Philosophy</a></h1>
<p>Application APIs should be future-proofed as much as possible</p>
<p>Application GUIs should be generally be as cross platform as possible.</p>
<p>There should be different modes of use for different user skill levels to try and accomidate as many people as possible.</p>
<ul>
<li>These modes should enable/disable various aspects of <em>configurability</em> in the application</li>
<li><strong>Simple</strong> mode should be super easy to use for anyone and come with a quick tutorial
<ul>
<li>Configuration options should be assumed as much as possible, </li>
</ul>
</li>
<li><strong>Default</strong> mode should come with a tutorial and explain how modes work and how to change them</li>
<li><strong>Advanced</strong> mode assumes the user already knows how to use the app or can figure it out on their own. All configurability functionality should be enabled.
<ul>
<li>Application developers should strive to implement as much configurability as possible into every aspect of their application for complex users.</li>
<li>For desktop applications, configuration on a small level (for specific contextual buttons or features) could be shown through right-click menus.</li>
<li>For mobile applications these configuration items can be shown through a long-press.</li>
</ul>
</li>
</ul>
<h1 id="why-copyright-is-cancer"><a class="header" href="#why-copyright-is-cancer">Why Copyright is Cancer</a></h1>
<p>Copyright is ineffective in the internet age. Any piece of content can be pirated on a massive scale without the original creator even knowing. The only thing copyright does is suppress derivative creation on forums with strict copyright adherence. See these videos on why <a href="https://www.youtube.com/watch?v=1Jwo5qc78QU">the current copyright system is broken</a> and why it <a href="https://www.youtube.com/watch?v=QVkeJI2feyQ">makes no sense</a>. This document outlines an alternate system of funding creation that Dither aims to create.</p>
<p><strong>Have a decentralized &amp; democratized forum of communication and publication that no institution or individual can meaningfully obstruct.</strong> Dither is a protocol for creating decentralized applications.</p>
<p><strong>Provide a direct connection of support between the consumers and the creators allowing people to directly support creators for the content they produce</strong> (<a href="https://www.youtube.com/watch?v=mnnYCJNhw7w">Paying for Production, not Distribution</a>). Even huge projects like Marvel movies or video games can be supported through community fundraising. Each production raises the reputation of the artist(s), allowing them to raise more money from their fans for the next project.</p>
<p><strong>Preventing artists from having control over their art allows all artists to use and adapt and <em>recreate</em> the work of other artists</strong>. Imagine all the games and movies that were super hyped up but totally flopped. If anyone was allowed to make anyone else's work but better, artists have an incentive to make good stories so that they can raise money for their next project, instead of making something crappy and making all their money off of preorders. This would also prevent the fragmentation of distribution services as no one entity can have exclusive control over a piece of content.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
